<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://facebook.github.com/immutable-js">immutable (v3.8.1)</a>
</h1>
<h4>Immutable Data Collections</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable">module immutable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection">
            function <span class="apidocSignatureSpan">immutable.</span>Collection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Indexed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Indexed.prototype.constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Keyed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Keyed.prototype.constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.</span>Collection.Set.prototype.constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable">
            function <span class="apidocSignatureSpan">immutable.</span>Iterable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator">
            function <span class="apidocSignatureSpan">immutable.</span>Iterable.Iterator
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List">
            function <span class="apidocSignatureSpan">immutable.</span>List
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map">
            function <span class="apidocSignatureSpan">immutable.</span>Map
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap">
            function <span class="apidocSignatureSpan">immutable.</span>OrderedMap
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet">
            function <span class="apidocSignatureSpan">immutable.</span>OrderedSet
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range">
            function <span class="apidocSignatureSpan">immutable.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record">
            function <span class="apidocSignatureSpan">immutable.</span>Record
            <span class="apidocSignatureSpan">(defaultValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat">
            function <span class="apidocSignatureSpan">immutable.</span>Repeat
            <span class="apidocSignatureSpan">(value, times)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq">
            function <span class="apidocSignatureSpan">immutable.</span>Seq
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed">
            function <span class="apidocSignatureSpan">immutable.</span>Seq.Indexed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed">
            function <span class="apidocSignatureSpan">immutable.</span>Seq.Keyed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set">
            function <span class="apidocSignatureSpan">immutable.</span>Seq.Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set">
            function <span class="apidocSignatureSpan">immutable.</span>Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack">
            function <span class="apidocSignatureSpan">immutable.</span>Stack
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.fromJS">
            function <span class="apidocSignatureSpan">immutable.</span>fromJS
            <span class="apidocSignatureSpan">(json, converter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.is">
            function <span class="apidocSignatureSpan">immutable.</span>is
            <span class="apidocSignatureSpan">(valueA, valueB)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Collection.Indexed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Collection.Keyed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Collection.Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Collection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Iterable.Indexed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Iterable.Iterator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Iterable.Keyed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Iterable.Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Iterable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>List.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Map.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>OrderedMap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>OrderedSet.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Range.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Record.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Repeat.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Seq.Indexed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Seq.Keyed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Seq.Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Seq.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Set.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">immutable.</span>Stack.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection">module immutable.Collection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Collection">
            function <span class="apidocSignatureSpan">immutable.</span>Collection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Indexed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Keyed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Indexed">module immutable.Collection.Indexed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.Indexed">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Indexed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Indexed.prototype">module immutable.Collection.Indexed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.filter">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.findIndex">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.findLastIndex">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>findLastIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.first">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.flatten">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>flatten
            <span class="apidocSignatureSpan">(depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>has
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.indexOf">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.interleave">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>interleave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.interpose">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>interpose
            <span class="apidocSignatureSpan">(separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.last">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.reverse">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.skipWhile">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.splice">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>splice
            <span class="apidocSignatureSpan">(index, removeNum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.toKeyedSeq">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>toKeyedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.zip">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.zipWith">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>zipWith
            <span class="apidocSignatureSpan">(zipper)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Indexed.prototype.constructor">module immutable.Collection.Indexed.prototype.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Keyed">module immutable.Collection.Keyed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.Keyed">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Keyed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Keyed.prototype">module immutable.Collection.Keyed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.__toJS">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>__toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.__toStringMapper">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>__toStringMapper
            <span class="apidocSignatureSpan">(v, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.flip">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>flip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.mapEntries">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>mapEntries
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.mapKeys">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>mapKeys
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Keyed.prototype.constructor">module immutable.Collection.Keyed.prototype.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Set">module immutable.Collection.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.Set">
            function <span class="apidocSignatureSpan">immutable.Collection.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Set.prototype">module immutable.Collection.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.contains">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>contains
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>get
            <span class="apidocSignatureSpan">(value, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>has
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>includes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.Set.prototype.constructor">module immutable.Collection.Set.prototype.constructor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.Set.prototype.constructor.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Collection.prototype">module immutable.Collection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Collection.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Collection.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable">module immutable.Iterable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterable">
            function <span class="apidocSignatureSpan">immutable.</span>Iterable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>Indexed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>Iterator
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>Keyed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.isAssociative">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>isAssociative
            <span class="apidocSignatureSpan">(maybeAssociative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.isIndexed">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>isIndexed
            <span class="apidocSignatureSpan">(maybeIndexed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.isIterable">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>isIterable
            <span class="apidocSignatureSpan">(maybeIterable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.isKeyed">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>isKeyed
            <span class="apidocSignatureSpan">(maybeKeyed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.isOrdered">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>isOrdered
            <span class="apidocSignatureSpan">(maybeOrdered)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.Indexed.prototype">module immutable.Iterable.Indexed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.filter">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.findIndex">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.findLastIndex">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>findLastIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.first">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.flatten">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>flatten
            <span class="apidocSignatureSpan">(depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>has
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.indexOf">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.interleave">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>interleave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.interpose">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>interpose
            <span class="apidocSignatureSpan">(separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.last">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.reverse">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.skipWhile">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.splice">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>splice
            <span class="apidocSignatureSpan">(index, removeNum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.toKeyedSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>toKeyedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.zip">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Indexed.prototype.zipWith">
            function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>zipWith
            <span class="apidocSignatureSpan">(zipper)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.Iterator">module immutable.Iterable.Iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator.Iterator">
            function <span class="apidocSignatureSpan">immutable.Iterable.</span>Iterator
            <span class="apidocSignatureSpan">(next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">immutable.Iterable.Iterator.</span>ENTRIES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">immutable.Iterable.Iterator.</span>KEYS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">immutable.Iterable.Iterator.</span>VALUES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.Iterator.prototype">module immutable.Iterable.Iterator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator.prototype.inspect">
            function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator.prototype.toSource">
            function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Iterator.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.Keyed.prototype">module immutable.Iterable.Keyed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.__toJS">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>__toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.__toStringMapper">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>__toStringMapper
            <span class="apidocSignatureSpan">(v, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.flip">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>flip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.mapEntries">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>mapEntries
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Keyed.prototype.mapKeys">
            function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>mapKeys
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.Set.prototype">module immutable.Iterable.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.contains">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>contains
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>get
            <span class="apidocSignatureSpan">(value, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>has
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>includes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.Set.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Iterable.prototype">module immutable.Iterable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.__toJS">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.__toString">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toString
            <span class="apidocSignatureSpan">(head, tail)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.__toStringMapper">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toStringMapper
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.butLast">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>butLast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.chain">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>chain
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.concat">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.contains">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>contains
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.count">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>count
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.countBy">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>countBy
            <span class="apidocSignatureSpan">(grouper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.entries">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>entries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.entrySeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>entrySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.equals">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.every">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>every
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.filter">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.filterNot">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>filterNot
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.find">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>find
            <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.findEntry">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findEntry
            <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.findKey">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findKey
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.findLast">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLast
            <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.findLastEntry">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLastEntry
            <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.findLastKey">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLastKey
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.first">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.flatMap">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>flatMap
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.flatten">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>flatten
            <span class="apidocSignatureSpan">(depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.forEach">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>forEach
            <span class="apidocSignatureSpan">(sideEffect, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.fromEntrySeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>fromEntrySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>get
            <span class="apidocSignatureSpan">(searchKey, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.getIn">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>getIn
            <span class="apidocSignatureSpan">(searchKeyPath, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.groupBy">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>groupBy
            <span class="apidocSignatureSpan">(grouper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>has
            <span class="apidocSignatureSpan">(searchKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.hasIn">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>hasIn
            <span class="apidocSignatureSpan">(searchKeyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.hashCode">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>hashCode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>includes
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.inspect">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.isEmpty">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.isSubset">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isSubset
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.isSuperset">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isSuperset
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.join">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>join
            <span class="apidocSignatureSpan">(separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.keyOf">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keyOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.keys">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.last">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.lastKeyOf">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>lastKeyOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.map">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>map
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.max">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>max
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.maxBy">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>maxBy
            <span class="apidocSignatureSpan">(mapper, comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.min">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>min
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.minBy">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>minBy
            <span class="apidocSignatureSpan">(mapper, comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.reduce">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reduce
            <span class="apidocSignatureSpan">(reducer, initialReduction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.reduceRight">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reduceRight
            <span class="apidocSignatureSpan">(reducer, initialReduction, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.rest">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>rest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.reverse">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.skip">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skip
            <span class="apidocSignatureSpan">(amount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.skipLast">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipLast
            <span class="apidocSignatureSpan">(amount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.skipUntil">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipUntil
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.skipWhile">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.some">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>some
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.sort">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>sort
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.sortBy">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>sortBy
            <span class="apidocSignatureSpan">(mapper, comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.take">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>take
            <span class="apidocSignatureSpan">(amount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.takeLast">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeLast
            <span class="apidocSignatureSpan">(amount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.takeUntil">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeUntil
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.takeWhile">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeWhile
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toArray">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toIndexedSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toIndexedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toJS">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toJSON">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toKeyedSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toKeyedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toList">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toMap">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toObject">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toObject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toOrderedMap">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toOrderedMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toOrderedSet">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toOrderedSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toSet">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toSetSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSetSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toSource">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSource
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toStack">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toStack
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.valueSeq">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>valueSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Iterable.prototype.values">
            function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>values
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.List">module immutable.List</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.List">
            function <span class="apidocSignatureSpan">immutable.</span>List
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.isList">
            function <span class="apidocSignatureSpan">immutable.List.</span>isList
            <span class="apidocSignatureSpan">(maybeList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.of">
            function <span class="apidocSignatureSpan">immutable.List.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.List.prototype">module immutable.List.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.asImmutable">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>asImmutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.asMutable">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>asMutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.delete">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>delete
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.deleteIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>deleteIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.get">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.insert">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>insert
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.merge">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.mergeDeep">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.mergeDeepIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeepIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.mergeDeepWith">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeepWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.mergeIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.mergeWith">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.pop">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.push">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>push
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.remove">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>remove
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.removeIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>removeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.set">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>set
            <span class="apidocSignatureSpan">(index, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.setIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>setIn
            <span class="apidocSignatureSpan">(keyPath, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.setSize">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>setSize
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.shift">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.unshift">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>unshift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.update">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>update
            <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.updateIn">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>updateIn
            <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.List.prototype.withMutations">
            function <span class="apidocSignatureSpan">immutable.List.prototype.</span>withMutations
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Map">module immutable.Map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.Map">
            function <span class="apidocSignatureSpan">immutable.</span>Map
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.isMap">
            function <span class="apidocSignatureSpan">immutable.Map.</span>isMap
            <span class="apidocSignatureSpan">(maybeMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.of">
            function <span class="apidocSignatureSpan">immutable.Map.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Map.prototype">module immutable.Map.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.asImmutable">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>asImmutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.asMutable">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>asMutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.delete">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>delete
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.deleteIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>deleteIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>get
            <span class="apidocSignatureSpan">(k, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.merge">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.mergeDeep">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.mergeDeepIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeepIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.mergeDeepWith">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeepWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.mergeIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.mergeWith">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.remove">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>remove
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.removeIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>removeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.set">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>set
            <span class="apidocSignatureSpan">(k, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.setIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>setIn
            <span class="apidocSignatureSpan">(keyPath, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.sort">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>sort
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.sortBy">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>sortBy
            <span class="apidocSignatureSpan">(mapper, comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.update">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>update
            <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.updateIn">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>updateIn
            <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Map.prototype.withMutations">
            function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>withMutations
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.OrderedMap">module immutable.OrderedMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.OrderedMap">
            function <span class="apidocSignatureSpan">immutable.</span>OrderedMap
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.isOrderedMap">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.</span>isOrderedMap
            <span class="apidocSignatureSpan">(maybeOrderedMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.of">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.OrderedMap.prototype">module immutable.OrderedMap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.delete">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>delete
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.get">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>get
            <span class="apidocSignatureSpan">(k, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.remove">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>remove
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.set">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>set
            <span class="apidocSignatureSpan">(k, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedMap.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.OrderedSet">module immutable.OrderedSet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.OrderedSet">
            function <span class="apidocSignatureSpan">immutable.</span>OrderedSet
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.fromKeys">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>fromKeys
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.isOrderedSet">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>isOrderedSet
            <span class="apidocSignatureSpan">(maybeOrderedSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.of">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.OrderedSet.prototype">module immutable.OrderedSet.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.prototype.__empty">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>__empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.prototype.__make">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>__make
            <span class="apidocSignatureSpan">(map, ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.OrderedSet.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Range">module immutable.Range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.Range">
            function <span class="apidocSignatureSpan">immutable.</span>Range
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Range.prototype">module immutable.Range.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>constructor
            <span class="apidocSignatureSpan">(start, end, step)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.equals">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>includes
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.indexOf">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Range.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Record">module immutable.Record</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.Record">
            function <span class="apidocSignatureSpan">immutable.</span>Record
            <span class="apidocSignatureSpan">(defaultValues, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Record.prototype">module immutable.Record.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.asImmutable">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>asImmutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.asMutable">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>asMutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>constructor
            <span class="apidocSignatureSpan">(defaultValues, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.delete">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>delete
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.deleteIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>deleteIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>get
            <span class="apidocSignatureSpan">(k, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>has
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.merge">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.mergeDeep">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.mergeDeepIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeepIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.mergeDeepWith">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeepWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.mergeIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.mergeWith">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.remove">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>remove
            <span class="apidocSignatureSpan">(k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.removeIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>removeIn
            <span class="apidocSignatureSpan">(keyPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.set">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>set
            <span class="apidocSignatureSpan">(k, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.setIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>setIn
            <span class="apidocSignatureSpan">(keyPath, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.update">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>update
            <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.updateIn">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>updateIn
            <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Record.prototype.withMutations">
            function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>withMutations
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Repeat">module immutable.Repeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.Repeat">
            function <span class="apidocSignatureSpan">immutable.</span>Repeat
            <span class="apidocSignatureSpan">(value, times)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Repeat.prototype">module immutable.Repeat.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value, times)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.equals">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>includes
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.indexOf">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.reverse">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Repeat.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq">module immutable.Seq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Seq">
            function <span class="apidocSignatureSpan">immutable.</span>Seq
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Indexed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Keyed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.isSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>isSeq
            <span class="apidocSignatureSpan">(maybeSeq)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.of">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Indexed">module immutable.Seq.Indexed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.Indexed">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Indexed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.of">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Indexed.prototype">module immutable.Seq.Indexed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.filter">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.findIndex">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.findLastIndex">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>findLastIndex
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.first">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>first
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.flatten">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>flatten
            <span class="apidocSignatureSpan">(depth)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>has
            <span class="apidocSignatureSpan">(index)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.indexOf">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.interleave">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>interleave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.interpose">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>interpose
            <span class="apidocSignatureSpan">(separator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.last">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>last
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.reverse">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>reverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.skipWhile">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.splice">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>splice
            <span class="apidocSignatureSpan">(index, removeNum)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.toIndexedSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toIndexedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.toKeyedSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toKeyedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.zip">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Indexed.prototype.zipWith">
            function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>zipWith
            <span class="apidocSignatureSpan">(zipper)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Keyed">module immutable.Seq.Keyed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.Keyed">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Keyed
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Keyed.prototype">module immutable.Seq.Keyed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.__toJS">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>__toJS
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.__toStringMapper">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>__toStringMapper
            <span class="apidocSignatureSpan">(v, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.flip">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>flip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.mapEntries">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>mapEntries
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.mapKeys">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>mapKeys
            <span class="apidocSignatureSpan">(mapper, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Keyed.prototype.toKeyedSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>toKeyedSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Set">module immutable.Seq.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.Set">
            function <span class="apidocSignatureSpan">immutable.Seq.</span>Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.of">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.Set.prototype">module immutable.Seq.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.contains">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>contains
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>get
            <span class="apidocSignatureSpan">(value, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>has
            <span class="apidocSignatureSpan">(searchValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.includes">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>includes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.keySeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>keySeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.Set.prototype.toSetSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>toSetSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Seq.prototype">module immutable.Seq.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.cacheResult">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>cacheResult
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.toSeq">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>toSeq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Seq.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Set">module immutable.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.Set">
            function <span class="apidocSignatureSpan">immutable.</span>Set
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.fromKeys">
            function <span class="apidocSignatureSpan">immutable.Set.</span>fromKeys
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.isSet">
            function <span class="apidocSignatureSpan">immutable.Set.</span>isSet
            <span class="apidocSignatureSpan">(maybeSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.of">
            function <span class="apidocSignatureSpan">immutable.Set.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Set.prototype">module immutable.Set.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.__empty">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.__make">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__make
            <span class="apidocSignatureSpan">(map, ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.add">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>add
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.asImmutable">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>asImmutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.asMutable">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>asMutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.delete">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>delete
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.has">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>has
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.intersect">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>intersect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.merge">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.mergeDeep">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.mergeDeepWith">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeDeepWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.mergeWith">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeWith
            <span class="apidocSignatureSpan">(merger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.remove">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>remove
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.sort">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>sort
            <span class="apidocSignatureSpan">(comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.sortBy">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>sortBy
            <span class="apidocSignatureSpan">(mapper, comparator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.subtract">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>subtract
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.union">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>union
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Set.prototype.withMutations">
            function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>withMutations
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Stack">module immutable.Stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.Stack">
            function <span class="apidocSignatureSpan">immutable.</span>Stack
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.isStack">
            function <span class="apidocSignatureSpan">immutable.Stack.</span>isStack
            <span class="apidocSignatureSpan">(maybeStack)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.of">
            function <span class="apidocSignatureSpan">immutable.Stack.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.immutable.Stack.prototype">module immutable.Stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.__ensureOwner">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__ensureOwner
            <span class="apidocSignatureSpan">(ownerID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.__iterate">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__iterate
            <span class="apidocSignatureSpan">(fn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.__iterator">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__iterator
            <span class="apidocSignatureSpan">(type, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.asImmutable">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>asImmutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.asMutable">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>asMutable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.clear">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.constructor">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>constructor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.get">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>get
            <span class="apidocSignatureSpan">(index, notSetValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.peek">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.pop">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.push">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>push
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.pushAll">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>pushAll
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.shift">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.slice">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.toString">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.unshift">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>unshift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.unshiftAll">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>unshiftAll
            <span class="apidocSignatureSpan">(iter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.wasAltered">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>wasAltered
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.immutable.Stack.prototype.withMutations">
            function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>withMutations
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable" id="apidoc.module.immutable">module immutable</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection" id="apidoc.element.immutable.Collection">
        function <span class="apidocSignatureSpan">immutable.</span>Collection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Collection() {
  throw TypeError('Abstract');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed" id="apidoc.element.immutable.Collection.Indexed">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Indexed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor" id="apidoc.element.immutable.Collection.Indexed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Indexed.prototype.constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedIterable(value) {
  return isIndexed(value) ? value : IndexedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed" id="apidoc.element.immutable.Collection.Keyed">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Keyed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor" id="apidoc.element.immutable.Collection.Keyed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Keyed.prototype.constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedIterable(value) {
  return isKeyed(value) ? value : KeyedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set" id="apidoc.element.immutable.Collection.Set">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.constructor" id="apidoc.element.immutable.Collection.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.</span>Collection.Set.prototype.constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetIterable(value) {
  return isIterable(value) &amp;&amp; !isAssociative(value) ? value : SetSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable" id="apidoc.element.immutable.Iterable">
        function <span class="apidocSignatureSpan">immutable.</span>Iterable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterable(value) {
  return isIterable(value) ? value : Seq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator" id="apidoc.element.immutable.Iterable.Iterator">
        function <span class="apidocSignatureSpan">immutable.</span>Iterable.Iterator
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(next) {
  this.next = next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List" id="apidoc.element.immutable.List">
        function <span class="apidocSignatureSpan">immutable.</span>List
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(value) {
  var empty = emptyList();
  if (value === null || value === undefined) {
    return empty;
  }
  if (isList(value)) {
    return value;
  }
  var iter = IndexedIterable(value);
  var size = iter.size;
  if (size === 0) {
    return empty;
  }
  assertNotInfinite(size);
  if (size &gt; 0 &amp;&amp; size &lt; SIZE) {
    return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
  }
  return empty.withMutations(function(list ) {
    list.setSize(size);
    iter.forEach(function(v, i)  {return list.set(i, v)});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map" id="apidoc.element.immutable.Map">
        function <span class="apidocSignatureSpan">immutable.</span>Map
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map(value) {
  return value === null || value === undefined ? emptyMap() :
    isMap(value) &amp;&amp; !isOrdered(value) ? value :
    emptyMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install immutable
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.<span class="apidocCodeKeywordSpan">Map</span>({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap" id="apidoc.element.immutable.OrderedMap">
        function <span class="apidocSignatureSpan">immutable.</span>OrderedMap
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedMap(value) {
  return value === null || value === undefined ? emptyOrderedMap() :
    isOrderedMap(value) ? value :
    emptyOrderedMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet" id="apidoc.element.immutable.OrderedSet">
        function <span class="apidocSignatureSpan">immutable.</span>OrderedSet
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedSet(value) {
  return value === null || value === undefined ? emptyOrderedSet() :
    isOrderedSet(value) ? value :
    emptyOrderedSet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range" id="apidoc.element.immutable.Range">
        function <span class="apidocSignatureSpan">immutable.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    return new Range(start, end, step);
  }
  invariant(step !== 0, 'Cannot step a Range by 0');
  start = start || 0;
  if (end === undefined) {
    end = Infinity;
  }
  step = step === undefined ? 1 : Math.abs(step);
  if (end &lt; start) {
    step = -step;
  }
  this._start = start;
  this._end = end;
  this._step = step;
  this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
  if (this.size === 0) {
    if (EMPTY_RANGE) {
      return EMPTY_RANGE;
    }
    EMPTY_RANGE = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
converting to a different concrete type (such as to a JS object):

seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

Immutable.<span class="apidocCodeKeywordSpan">Range</span>(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
  .filter(n =&gt; n % 2 === 0)
  .take(2)
  .reduce((r, n) =&gt; r * n, 1);
// 1006008
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record" id="apidoc.element.immutable.Record">
        function <span class="apidocSignatureSpan">immutable.</span>Record
        <span class="apidocSignatureSpan">(defaultValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      setProps(RecordTypePrototype, keys);
      RecordTypePrototype.size = keys.length;
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
    }
    this._map = Map(values);
  };

  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;

  return RecordType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat" id="apidoc.element.immutable.Repeat">
        function <span class="apidocSignatureSpan">immutable.</span>Repeat
        <span class="apidocSignatureSpan">(value, times)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Repeat(value, times) {
  if (!(this instanceof Repeat)) {
    return new Repeat(value, times);
  }
  this._value = value;
  this.size = times === undefined ? Infinity : Math.max(0, times);
  if (this.size === 0) {
    if (EMPTY_REPEAT) {
      return EMPTY_REPEAT;
    }
    EMPTY_REPEAT = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq" id="apidoc.element.immutable.Seq">
        function <span class="apidocSignatureSpan">immutable.</span>Seq
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(value) {
  return value === null || value === undefined ? emptySequence() :
    isIterable(value) ? value.toSeq() : seqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
results, these operations can be extremely efficient.

```javascript
var myObject = {a:1,b:2,c:3};
Immutable.<span class="apidocCodeKeywordSpan">Seq</span>(myObject).map(x =&gt; x * x).toObject();
// { a: 1, b: 4, c: 9 }
```

Keep in mind, when using JS objects to construct Immutable Maps, that
JavaScript Object properties are always strings, even if written in a quote-less
shorthand, while Immutable Maps accept keys of any type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed" id="apidoc.element.immutable.Seq.Indexed">
        function <span class="apidocSignatureSpan">immutable.</span>Seq.Indexed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedSeq(value) {
  return value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed" id="apidoc.element.immutable.Seq.Keyed">
        function <span class="apidocSignatureSpan">immutable.</span>Seq.Keyed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedSeq(value) {
  return value === null || value === undefined ?
    emptySequence().toKeyedSeq() :
    isIterable(value) ?
      (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
      keyedSeqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set" id="apidoc.element.immutable.Seq.Set">
        function <span class="apidocSignatureSpan">immutable.</span>Seq.Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetSeq(value) {
  return (
    value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value
  ).toSetSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set" id="apidoc.element.immutable.Set">
        function <span class="apidocSignatureSpan">immutable.</span>Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(value) {
  return value === null || value === undefined ? emptySet() :
    isSet(value) &amp;&amp; !isOrdered(value) ? value :
    emptySet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack" id="apidoc.element.immutable.Stack">
        function <span class="apidocSignatureSpan">immutable.</span>Stack
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack(value) {
  return value === null || value === undefined ? emptyStack() :
    isStack(value) ? value :
    emptyStack().unshiftAll(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.fromJS" id="apidoc.element.immutable.fromJS">
        function <span class="apidocSignatureSpan">immutable.</span>fromJS
        <span class="apidocSignatureSpan">(json, converter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJS(json, converter) {
  return converter ?
    fromJSWith(converter, json, '', {'': json}) :
    fromJSDefault(json);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
var obj = { 1: "one" };
Object.keys(obj); // [ "1" ]
obj["1"]; // "one"
obj[1];   // "one"

var map = Immutable.<span class="apidocCodeKeywordSpan">fromJS</span>(obj);
map.get("1"); // "one"
map.get(1);   // undefined
```

Property access for JavaScript Objects first converts the key to a string, but
since Immutable Map keys can be of any type the argument to `get()` is
not altered.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.is" id="apidoc.element.immutable.is">
        function <span class="apidocSignatureSpan">immutable.</span>is
        <span class="apidocSignatureSpan">(valueA, valueB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function is(valueA, valueB) {
  if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === 'function' &amp;&amp;
      typeof valueB.valueOf === 'function') {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || (valueA !== valueA &amp;&amp; valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  if (typeof valueA.equals === 'function' &amp;&amp;
      typeof valueB.equals === 'function' &amp;&amp;
      valueA.equals(valueB)) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
interested in doing work when something has changed, you can use equality.

Immutable collections should be treated as *values* rather than *objects*. While
objects represents some thing which could change over time, a value represents
the state of that thing at a particular instance of time. This principle is most
important to understanding the appropriate use of immutable data. In order to
treat Immutable.js collections as values, it's important to use the
`Immutable.<span class="apidocCodeKeywordSpan">is</span>()` function or `.equals()` method to determine value equality
instead of the `===` operator which determines object reference identity.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 2);
assert(map1.equals(map2) === true);
var map3 = map1.set('b', 50);
...</pre></li>
    </ul>














































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection" id="apidoc.module.immutable.Collection">module immutable.Collection</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Collection" id="apidoc.element.immutable.Collection.Collection">
        function <span class="apidocSignatureSpan">immutable.</span>Collection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Collection() {
  throw TypeError('Abstract');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed" id="apidoc.element.immutable.Collection.Indexed">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Indexed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed" id="apidoc.element.immutable.Collection.Keyed">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Keyed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set" id="apidoc.element.immutable.Collection.Set">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Indexed" id="apidoc.module.immutable.Collection.Indexed">module immutable.Collection.Indexed</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.Indexed" id="apidoc.element.immutable.Collection.Indexed.Indexed">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Indexed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Indexed.prototype" id="apidoc.module.immutable.Collection.Indexed.prototype">module immutable.Collection.Indexed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor" id="apidoc.element.immutable.Collection.Indexed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedIterable(value) {
  return isIndexed(value) ? value : IndexedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.filter" id="apidoc.element.immutable.Collection.Indexed.prototype.filter">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (predicate, context) {
  return reify(this, filterFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Seq is lazy** â€” Seq does as little work as necessary to respond to any
method call.

For example, the following does not perform any work, because the resulting
Seq is never used:

var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .<span class="apidocCodeKeywordSpan">filter</span>(x =&gt; x % 2).map(x =&gt; x * x);

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.findIndex" id="apidoc.element.immutable.Collection.Indexed.prototype.findIndex">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findIndex = function (predicate, context) {
  var entry = this.findEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.findLastIndex" id="apidoc.element.immutable.Collection.Indexed.prototype.findLastIndex">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>findLastIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastIndex = function (predicate, context) {
  var entry = this.findLastEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.first" id="apidoc.element.immutable.Collection.Indexed.prototype.first">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this.get(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.flatten" id="apidoc.element.immutable.Collection.Indexed.prototype.flatten">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>flatten
        <span class="apidocSignatureSpan">(depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (depth) {
  return reify(this, flattenFactory(this, depth, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.get" id="apidoc.element.immutable.Collection.Indexed.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  index = wrapIndex(this, index);
  return (index &lt; 0 || (this.size === Infinity ||
      (this.size !== undefined &amp;&amp; index &gt; this.size))) ?
    notSetValue :
    this.find(function(_, key)  {return key === index}, undefined, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.has" id="apidoc.element.immutable.Collection.Indexed.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>has
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (index) {
  index = wrapIndex(this, index);
  return index &gt;= 0 &amp;&amp; (this.size !== undefined ?
    this.size === Infinity || index &lt; this.size :
    this.indexOf(index) !== -1
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.indexOf" id="apidoc.element.immutable.Collection.Indexed.prototype.indexOf">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchValue) {
  var key = this.keyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.interleave" id="apidoc.element.immutable.Collection.Indexed.prototype.interleave">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>interleave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interleave = function () {
  var iterables = [this].concat(arrCopy(arguments));
  var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
  var interleaved = zipped.flatten(true);
  if (zipped.size) {
    interleaved.size = zipped.size * iterables.length;
  }
  return reify(this, interleaved);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.interpose" id="apidoc.element.immutable.Collection.Indexed.prototype.interpose">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>interpose
        <span class="apidocSignatureSpan">(separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpose = function (separator) {
  return reify(this, interposeFactory(this, separator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.keySeq" id="apidoc.element.immutable.Collection.Indexed.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return Range(0, this.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.last" id="apidoc.element.immutable.Collection.Indexed.prototype.last">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.get(-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.lastIndexOf" id="apidoc.element.immutable.Collection.Indexed.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchValue) {
  var key = this.lastKeyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.reverse" id="apidoc.element.immutable.Collection.Indexed.prototype.reverse">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return reify(this, reverseFactory(this, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.skipWhile" id="apidoc.element.immutable.Collection.Indexed.prototype.skipWhile">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (predicate, context) {
  return reify(this, skipWhileFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.slice" id="apidoc.element.immutable.Collection.Indexed.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  return reify(this, sliceFactory(this, begin, end, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.splice" id="apidoc.element.immutable.Collection.Indexed.prototype.splice">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>splice
        <span class="apidocSignatureSpan">(index, removeNum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (index, removeNum) {
  var numArgs = arguments.length;
  removeNum = Math.max(removeNum | 0, 0);
  if (numArgs === 0 || (numArgs === 2 &amp;&amp; !removeNum)) {
    return this;
  }
  // If index is negative, it should resolve relative to the size of the
  // collection. However size may be expensive to compute if not cached, so
  // only call count() if the number is in fact negative.
  index = resolveBegin(index, index &lt; 0 ? this.count() : this.size);
  var spliced = this.slice(0, index);
  return reify(
    this,
    numArgs === 1 ?
      spliced :
      spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.toKeyedSeq" id="apidoc.element.immutable.Collection.Indexed.prototype.toKeyedSeq">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>toKeyedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKeyedSeq = function () {
  return new ToKeyedSequence(this, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.zip" id="apidoc.element.immutable.Collection.Indexed.prototype.zip">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  var iterables = [this].concat(arrCopy(arguments));
  return reify(this, zipWithFactory(this, defaultZipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.zipWith" id="apidoc.element.immutable.Collection.Indexed.prototype.zipWith">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>zipWith
        <span class="apidocSignatureSpan">(zipper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipWith = function (zipper) {
  var iterables = arrCopy(arguments);
  iterables[0] = this;
  return reify(this, zipWithFactory(this, zipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Indexed.prototype.constructor" id="apidoc.module.immutable.Collection.Indexed.prototype.constructor">module immutable.Collection.Indexed.prototype.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Indexed.prototype.constructor.constructor" id="apidoc.element.immutable.Collection.Indexed.prototype.constructor.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Indexed.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Keyed" id="apidoc.module.immutable.Collection.Keyed">module immutable.Collection.Keyed</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.Keyed" id="apidoc.element.immutable.Collection.Keyed.Keyed">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Keyed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Keyed.prototype" id="apidoc.module.immutable.Collection.Keyed.prototype">module immutable.Collection.Keyed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.__toJS" id="apidoc.element.immutable.Collection.Keyed.prototype.__toJS">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>__toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toJS = function () {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k)  { object[k] = v; });
  return object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.__toStringMapper" id="apidoc.element.immutable.Collection.Keyed.prototype.__toStringMapper">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>__toStringMapper
        <span class="apidocSignatureSpan">(v, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toStringMapper = function (v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor" id="apidoc.element.immutable.Collection.Keyed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedIterable(value) {
  return isKeyed(value) ? value : KeyedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.flip" id="apidoc.element.immutable.Collection.Keyed.prototype.flip">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>flip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flip = function () {
  return reify(this, flipFactory(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Any collection can be converted to a lazy Seq with `.toSeq()`.

var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();

Seq allow for the efficient chaining of sequence operations, especially when
converting to a different concrete type (such as to a JS object):

seq.<span class="apidocCodeKeywordSpan">flip</span>().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

Immutable.Range(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.mapEntries" id="apidoc.element.immutable.Collection.Keyed.prototype.mapEntries">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>mapEntries
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapEntries = function (mapper, context) {var this$0 = this;
  var iterations = 0;
  return reify(this,
    this.toSeq().map(
      function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
    ).fromEntrySeq()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.mapKeys" id="apidoc.element.immutable.Collection.Keyed.prototype.mapKeys">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>mapKeys
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapKeys = function (mapper, context) {var this$0 = this;
  return reify(this,
    this.toSeq().flip().map(
      function(k, v)  {return mapper.call(context, k, v, this$0)}
    ).flip()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Keyed.prototype.constructor" id="apidoc.module.immutable.Collection.Keyed.prototype.constructor">module immutable.Collection.Keyed.prototype.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Keyed.prototype.constructor.constructor" id="apidoc.element.immutable.Collection.Keyed.prototype.constructor.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Keyed.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Set" id="apidoc.module.immutable.Collection.Set">module immutable.Collection.Set</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.Set" id="apidoc.element.immutable.Collection.Set.Set">
        function <span class="apidocSignatureSpan">immutable.Collection.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetCollection() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Set.prototype" id="apidoc.module.immutable.Collection.Set.prototype">module immutable.Collection.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.constructor" id="apidoc.element.immutable.Collection.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetIterable(value) {
  return isIterable(value) &amp;&amp; !isAssociative(value) ? value : SetSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.contains" id="apidoc.element.immutable.Collection.Set.prototype.contains">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>contains
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.get" id="apidoc.element.immutable.Collection.Set.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>get
        <span class="apidocSignatureSpan">(value, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (value, notSetValue) {
  return this.has(value) ? value : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.has" id="apidoc.element.immutable.Collection.Set.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>has
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (searchValue) {
  return this.some(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.includes" id="apidoc.element.immutable.Collection.Set.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>includes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.keySeq" id="apidoc.element.immutable.Collection.Set.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return this.valueSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.Set.prototype.constructor" id="apidoc.module.immutable.Collection.Set.prototype.constructor">module immutable.Collection.Set.prototype.constructor</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.Set.prototype.constructor.constructor" id="apidoc.element.immutable.Collection.Set.prototype.constructor.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Function() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Collection.prototype" id="apidoc.module.immutable.Collection.prototype">module immutable.Collection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Collection.prototype.constructor" id="apidoc.element.immutable.Collection.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Collection.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Collection() {
  throw TypeError('Abstract');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable" id="apidoc.module.immutable.Iterable">module immutable.Iterable</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterable" id="apidoc.element.immutable.Iterable.Iterable">
        function <span class="apidocSignatureSpan">immutable.</span>Iterable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterable(value) {
  return isIterable(value) ? value : Seq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed" id="apidoc.element.immutable.Iterable.Indexed">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>Indexed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedIterable(value) {
  return isIndexed(value) ? value : IndexedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator" id="apidoc.element.immutable.Iterable.Iterator">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>Iterator
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(next) {
  this.next = next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed" id="apidoc.element.immutable.Iterable.Keyed">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>Keyed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedIterable(value) {
  return isKeyed(value) ? value : KeyedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set" id="apidoc.element.immutable.Iterable.Set">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetIterable(value) {
  return isIterable(value) &amp;&amp; !isAssociative(value) ? value : SetSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.isAssociative" id="apidoc.element.immutable.Iterable.isAssociative">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>isAssociative
        <span class="apidocSignatureSpan">(maybeAssociative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.isIndexed" id="apidoc.element.immutable.Iterable.isIndexed">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>isIndexed
        <span class="apidocSignatureSpan">(maybeIndexed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIndexed(maybeIndexed) {
  return !!(maybeIndexed &amp;&amp; maybeIndexed[IS_INDEXED_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.isIterable" id="apidoc.element.immutable.Iterable.isIterable">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>isIterable
        <span class="apidocSignatureSpan">(maybeIterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIterable(maybeIterable) {
  return !!(maybeIterable &amp;&amp; maybeIterable[IS_ITERABLE_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.isKeyed" id="apidoc.element.immutable.Iterable.isKeyed">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>isKeyed
        <span class="apidocSignatureSpan">(maybeKeyed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKeyed(maybeKeyed) {
  return !!(maybeKeyed &amp;&amp; maybeKeyed[IS_KEYED_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.isOrdered" id="apidoc.element.immutable.Iterable.isOrdered">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>isOrdered
        <span class="apidocSignatureSpan">(maybeOrdered)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOrdered(maybeOrdered) {
  return !!(maybeOrdered &amp;&amp; maybeOrdered[IS_ORDERED_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.Indexed.prototype" id="apidoc.module.immutable.Iterable.Indexed.prototype">module immutable.Iterable.Indexed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.constructor" id="apidoc.element.immutable.Iterable.Indexed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedIterable(value) {
  return isIndexed(value) ? value : IndexedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.filter" id="apidoc.element.immutable.Iterable.Indexed.prototype.filter">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (predicate, context) {
  return reify(this, filterFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Seq is lazy** â€” Seq does as little work as necessary to respond to any
method call.

For example, the following does not perform any work, because the resulting
Seq is never used:

var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .<span class="apidocCodeKeywordSpan">filter</span>(x =&gt; x % 2).map(x =&gt; x * x);

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.findIndex" id="apidoc.element.immutable.Iterable.Indexed.prototype.findIndex">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findIndex = function (predicate, context) {
  var entry = this.findEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.findLastIndex" id="apidoc.element.immutable.Iterable.Indexed.prototype.findLastIndex">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>findLastIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastIndex = function (predicate, context) {
  var entry = this.findLastEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.first" id="apidoc.element.immutable.Iterable.Indexed.prototype.first">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this.get(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.flatten" id="apidoc.element.immutable.Iterable.Indexed.prototype.flatten">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>flatten
        <span class="apidocSignatureSpan">(depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (depth) {
  return reify(this, flattenFactory(this, depth, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.get" id="apidoc.element.immutable.Iterable.Indexed.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  index = wrapIndex(this, index);
  return (index &lt; 0 || (this.size === Infinity ||
      (this.size !== undefined &amp;&amp; index &gt; this.size))) ?
    notSetValue :
    this.find(function(_, key)  {return key === index}, undefined, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.has" id="apidoc.element.immutable.Iterable.Indexed.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>has
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (index) {
  index = wrapIndex(this, index);
  return index &gt;= 0 &amp;&amp; (this.size !== undefined ?
    this.size === Infinity || index &lt; this.size :
    this.indexOf(index) !== -1
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.indexOf" id="apidoc.element.immutable.Iterable.Indexed.prototype.indexOf">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchValue) {
  var key = this.keyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.interleave" id="apidoc.element.immutable.Iterable.Indexed.prototype.interleave">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>interleave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interleave = function () {
  var iterables = [this].concat(arrCopy(arguments));
  var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
  var interleaved = zipped.flatten(true);
  if (zipped.size) {
    interleaved.size = zipped.size * iterables.length;
  }
  return reify(this, interleaved);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.interpose" id="apidoc.element.immutable.Iterable.Indexed.prototype.interpose">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>interpose
        <span class="apidocSignatureSpan">(separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpose = function (separator) {
  return reify(this, interposeFactory(this, separator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.keySeq" id="apidoc.element.immutable.Iterable.Indexed.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return Range(0, this.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.last" id="apidoc.element.immutable.Iterable.Indexed.prototype.last">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.get(-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.lastIndexOf" id="apidoc.element.immutable.Iterable.Indexed.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchValue) {
  var key = this.lastKeyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.reverse" id="apidoc.element.immutable.Iterable.Indexed.prototype.reverse">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return reify(this, reverseFactory(this, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.skipWhile" id="apidoc.element.immutable.Iterable.Indexed.prototype.skipWhile">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (predicate, context) {
  return reify(this, skipWhileFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.slice" id="apidoc.element.immutable.Iterable.Indexed.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  return reify(this, sliceFactory(this, begin, end, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.splice" id="apidoc.element.immutable.Iterable.Indexed.prototype.splice">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>splice
        <span class="apidocSignatureSpan">(index, removeNum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (index, removeNum) {
  var numArgs = arguments.length;
  removeNum = Math.max(removeNum | 0, 0);
  if (numArgs === 0 || (numArgs === 2 &amp;&amp; !removeNum)) {
    return this;
  }
  // If index is negative, it should resolve relative to the size of the
  // collection. However size may be expensive to compute if not cached, so
  // only call count() if the number is in fact negative.
  index = resolveBegin(index, index &lt; 0 ? this.count() : this.size);
  var spliced = this.slice(0, index);
  return reify(
    this,
    numArgs === 1 ?
      spliced :
      spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.toKeyedSeq" id="apidoc.element.immutable.Iterable.Indexed.prototype.toKeyedSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>toKeyedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKeyedSeq = function () {
  return new ToKeyedSequence(this, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.zip" id="apidoc.element.immutable.Iterable.Indexed.prototype.zip">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  var iterables = [this].concat(arrCopy(arguments));
  return reify(this, zipWithFactory(this, defaultZipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Indexed.prototype.zipWith" id="apidoc.element.immutable.Iterable.Indexed.prototype.zipWith">
        function <span class="apidocSignatureSpan">immutable.Iterable.Indexed.prototype.</span>zipWith
        <span class="apidocSignatureSpan">(zipper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipWith = function (zipper) {
  var iterables = arrCopy(arguments);
  iterables[0] = this;
  return reify(this, zipWithFactory(this, zipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.Iterator" id="apidoc.module.immutable.Iterable.Iterator">module immutable.Iterable.Iterator</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator.Iterator" id="apidoc.element.immutable.Iterable.Iterator.Iterator">
        function <span class="apidocSignatureSpan">immutable.Iterable.</span>Iterator
        <span class="apidocSignatureSpan">(next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Iterator(next) {
  this.next = next;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.Iterator.prototype" id="apidoc.module.immutable.Iterable.Iterator.prototype">module immutable.Iterable.Iterator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator.prototype.inspect" id="apidoc.element.immutable.Iterable.Iterator.prototype.inspect">
        function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () { return this.toString(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator.prototype.toSource" id="apidoc.element.immutable.Iterable.Iterator.prototype.toSource">
        function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () { return this.toString(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Iterator.prototype.toString" id="apidoc.element.immutable.Iterable.Iterator.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Iterable.Iterator.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return '[Iterator]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.Keyed.prototype" id="apidoc.module.immutable.Iterable.Keyed.prototype">module immutable.Iterable.Keyed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.__toJS" id="apidoc.element.immutable.Iterable.Keyed.prototype.__toJS">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>__toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toJS = function () {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k)  { object[k] = v; });
  return object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.__toStringMapper" id="apidoc.element.immutable.Iterable.Keyed.prototype.__toStringMapper">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>__toStringMapper
        <span class="apidocSignatureSpan">(v, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toStringMapper = function (v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.constructor" id="apidoc.element.immutable.Iterable.Keyed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedIterable(value) {
  return isKeyed(value) ? value : KeyedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.flip" id="apidoc.element.immutable.Iterable.Keyed.prototype.flip">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>flip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flip = function () {
  return reify(this, flipFactory(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Any collection can be converted to a lazy Seq with `.toSeq()`.

var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();

Seq allow for the efficient chaining of sequence operations, especially when
converting to a different concrete type (such as to a JS object):

seq.<span class="apidocCodeKeywordSpan">flip</span>().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

Immutable.Range(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.mapEntries" id="apidoc.element.immutable.Iterable.Keyed.prototype.mapEntries">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>mapEntries
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapEntries = function (mapper, context) {var this$0 = this;
  var iterations = 0;
  return reify(this,
    this.toSeq().map(
      function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
    ).fromEntrySeq()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Keyed.prototype.mapKeys" id="apidoc.element.immutable.Iterable.Keyed.prototype.mapKeys">
        function <span class="apidocSignatureSpan">immutable.Iterable.Keyed.prototype.</span>mapKeys
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapKeys = function (mapper, context) {var this$0 = this;
  return reify(this,
    this.toSeq().flip().map(
      function(k, v)  {return mapper.call(context, k, v, this$0)}
    ).flip()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.Set.prototype" id="apidoc.module.immutable.Iterable.Set.prototype">module immutable.Iterable.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.constructor" id="apidoc.element.immutable.Iterable.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetIterable(value) {
  return isIterable(value) &amp;&amp; !isAssociative(value) ? value : SetSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.contains" id="apidoc.element.immutable.Iterable.Set.prototype.contains">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>contains
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.get" id="apidoc.element.immutable.Iterable.Set.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>get
        <span class="apidocSignatureSpan">(value, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (value, notSetValue) {
  return this.has(value) ? value : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.has" id="apidoc.element.immutable.Iterable.Set.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>has
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (searchValue) {
  return this.some(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.includes" id="apidoc.element.immutable.Iterable.Set.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>includes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.Set.prototype.keySeq" id="apidoc.element.immutable.Iterable.Set.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.Set.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return this.valueSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Iterable.prototype" id="apidoc.module.immutable.Iterable.prototype">module immutable.Iterable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.__toJS" id="apidoc.element.immutable.Iterable.prototype.__toJS">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toJS = function () {
  assertNotInfinite(this.size);
  var array = new Array(this.size || 0);
  this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.__toString" id="apidoc.element.immutable.Iterable.prototype.__toString">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toString
        <span class="apidocSignatureSpan">(head, tail)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toString = function (head, tail) {
  if (this.size === 0) {
    return head + tail;
  }
  return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.__toStringMapper" id="apidoc.element.immutable.Iterable.prototype.__toStringMapper">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>__toStringMapper
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function quoteString(value) {
  return typeof value === 'string' ? JSON.stringify(value) : String(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.butLast" id="apidoc.element.immutable.Iterable.prototype.butLast">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>butLast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">butLast = function () {
  return this.slice(0, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.chain" id="apidoc.element.immutable.Iterable.prototype.chain">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>chain
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chain = function (mapper, context) {
  return reify(this, flatMapFactory(this, mapper, context));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.concat" id="apidoc.element.immutable.Iterable.prototype.concat">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function () {var values = SLICE$0.call(arguments, 0);
  return reify(this, concatFactory(this, values));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.of(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.<span class="apidocCodeKeywordSpan">concat</span>(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
assert(list4.get(0) === 1);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.contains" id="apidoc.element.immutable.Iterable.prototype.contains">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>contains
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (searchValue) {
  return this.some(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.count" id="apidoc.element.immutable.Iterable.prototype.count">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>count
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (predicate, context) {
  return ensureSize(
    predicate ? this.toSeq().filter(predicate, context) : this
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.countBy" id="apidoc.element.immutable.Iterable.prototype.countBy">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>countBy
        <span class="apidocSignatureSpan">(grouper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">countBy = function (grouper, context) {
  return countByFactory(this, grouper, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.entries" id="apidoc.element.immutable.Iterable.prototype.entries">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>entries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entries = function () {
  return this.__iterator(ITERATE_ENTRIES);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.entrySeq" id="apidoc.element.immutable.Iterable.prototype.entrySeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>entrySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entrySeq = function () {
  var iterable = this;
  if (iterable._cache) {
    // We cache as an entries array, so we can just return the cache!
    return new ArraySeq(iterable._cache);
  }
  var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
  entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
  return entriesSequence;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.equals" id="apidoc.element.immutable.Iterable.prototype.equals">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return deepEqual(this, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
interested in doing work when something has changed, you can use equality.

Immutable collections should be treated as *values* rather than *objects*. While
objects represents some thing which could change over time, a value represents
the state of that thing at a particular instance of time. This principle is most
important to understanding the appropriate use of immutable data. In order to
treat Immutable.js collections as values, it's important to use the
`Immutable.is()` function or `.<span class="apidocCodeKeywordSpan">equals</span>()` method to determine value equality
instead of the `===` operator which determines object reference identity.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 2);
assert(map1.equals(map2) === true);
var map3 = map1.set('b', 50);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.every" id="apidoc.element.immutable.Iterable.prototype.every">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>every
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (predicate, context) {
  assertNotInfinite(this.size);
  var returnValue = true;
  this.__iterate(function(v, k, c)  {
    if (!predicate.call(context, v, k, c)) {
      returnValue = false;
      return false;
    }
  });
  return returnValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.filter" id="apidoc.element.immutable.Iterable.prototype.filter">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (predicate, context) {
  return reify(this, filterFactory(this, predicate, context, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Seq is lazy** â€” Seq does as little work as necessary to respond to any
method call.

For example, the following does not perform any work, because the resulting
Seq is never used:

var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .<span class="apidocCodeKeywordSpan">filter</span>(x =&gt; x % 2).map(x =&gt; x * x);

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.filterNot" id="apidoc.element.immutable.Iterable.prototype.filterNot">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>filterNot
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterNot = function (predicate, context) {
  return this.filter(not(predicate), context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.find" id="apidoc.element.immutable.Iterable.prototype.find">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>find
        <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (predicate, context, notSetValue) {
  var entry = this.findEntry(predicate, context);
  return entry ? entry[1] : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.findEntry" id="apidoc.element.immutable.Iterable.prototype.findEntry">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findEntry
        <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findEntry = function (predicate, context, notSetValue) {
  var found = notSetValue;
  this.__iterate(function(v, k, c)  {
    if (predicate.call(context, v, k, c)) {
      found = [k, v];
      return false;
    }
  });
  return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.findKey" id="apidoc.element.immutable.Iterable.prototype.findKey">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findKey
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findKey = function (predicate, context) {
  var entry = this.findEntry(predicate, context);
  return entry &amp;&amp; entry[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.findLast" id="apidoc.element.immutable.Iterable.prototype.findLast">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLast
        <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLast = function (predicate, context, notSetValue) {
  return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.findLastEntry" id="apidoc.element.immutable.Iterable.prototype.findLastEntry">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLastEntry
        <span class="apidocSignatureSpan">(predicate, context, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastEntry = function (predicate, context, notSetValue) {
  return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.findLastKey" id="apidoc.element.immutable.Iterable.prototype.findLastKey">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>findLastKey
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastKey = function (predicate, context) {
  return this.toKeyedSeq().reverse().findKey(predicate, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.first" id="apidoc.element.immutable.Iterable.prototype.first">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this.find(returnTrue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.flatMap" id="apidoc.element.immutable.Iterable.prototype.flatMap">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>flatMap
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatMap = function (mapper, context) {
  return reify(this, flatMapFactory(this, mapper, context));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.flatten" id="apidoc.element.immutable.Iterable.prototype.flatten">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>flatten
        <span class="apidocSignatureSpan">(depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (depth) {
  return reify(this, flattenFactory(this, depth, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.forEach" id="apidoc.element.immutable.Iterable.prototype.forEach">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>forEach
        <span class="apidocSignatureSpan">(sideEffect, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (sideEffect, context) {
  assertNotInfinite(this.size);
  return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.fromEntrySeq" id="apidoc.element.immutable.Iterable.prototype.fromEntrySeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>fromEntrySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEntrySeq = function () {
  return new FromEntriesSequence(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.get" id="apidoc.element.immutable.Iterable.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>get
        <span class="apidocSignatureSpan">(searchKey, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (searchKey, notSetValue) {
  return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.getIn" id="apidoc.element.immutable.Iterable.prototype.getIn">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>getIn
        <span class="apidocSignatureSpan">(searchKeyPath, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIn = function (searchKeyPath, notSetValue) {
  var nested = this;
  // Note: in an ES6 environment, we would prefer:
  // for (var key of searchKeyPath) {
  var iter = forceIterator(searchKeyPath);
  var step;
  while (!(step = iter.next()).done) {
    var key = step.value;
    nested = nested &amp;&amp; nested.get ? nested.get(key, NOT_SET) : NOT_SET;
    if (nested === NOT_SET) {
      return notSetValue;
    }
  }
  return nested;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var nested2 = nested.mergeDeep({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.<span class="apidocCodeKeywordSpan">getIn</span>(['a', 'b', 'd']); // 6

var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }

var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.groupBy" id="apidoc.element.immutable.Iterable.prototype.groupBy">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>groupBy
        <span class="apidocSignatureSpan">(grouper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (grouper, context) {
  return groupByFactory(this, grouper, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.has" id="apidoc.element.immutable.Iterable.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>has
        <span class="apidocSignatureSpan">(searchKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (searchKey) {
  return this.get(searchKey, NOT_SET) !== NOT_SET;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.hasIn" id="apidoc.element.immutable.Iterable.prototype.hasIn">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>hasIn
        <span class="apidocSignatureSpan">(searchKeyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasIn = function (searchKeyPath) {
  return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.hashCode" id="apidoc.element.immutable.Iterable.prototype.hashCode">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>hashCode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hashCode = function () {
  return this.__hash || (this.__hash = hashIterable(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.includes" id="apidoc.element.immutable.Iterable.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>includes
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (searchValue) {
  return this.some(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.inspect" id="apidoc.element.immutable.Iterable.prototype.inspect">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () { return this.toString(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.isEmpty" id="apidoc.element.immutable.Iterable.prototype.isEmpty">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function () {
  return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.isSubset" id="apidoc.element.immutable.Iterable.prototype.isSubset">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isSubset
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSubset = function (iter) {
  iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
  return this.every(function(value ) {return iter.includes(value)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.isSuperset" id="apidoc.element.immutable.Iterable.prototype.isSuperset">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>isSuperset
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSuperset = function (iter) {
  iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
  return iter.isSubset(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.join" id="apidoc.element.immutable.Iterable.prototype.join">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>join
        <span class="apidocSignatureSpan">(separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">join = function (separator) {
  assertNotInfinite(this.size);
  separator = separator !== undefined ? '' + separator : ',';
  var joined = '';
  var isFirst = true;
  this.__iterate(function(v ) {
    isFirst ? (isFirst = false) : (joined += separator);
    joined += v !== null &amp;&amp; v !== undefined ? v.toString() : '';
  });
  return joined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Almost all of the methods on [Array][] will be found in similar form on
`Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][]
found on `Immutable.Set`, including collection operations like `forEach()`
and `map()`.

```javascript
var alpha = Immutable.Map({a:1, b:2, c:3, d:4});
alpha.map((v, k) =&gt; k.toUpperCase()).<span class="apidocCodeKeywordSpan">join</span>();
// 'A,B,C,D'
```

### Accepts raw JavaScript objects.

Designed to inter-operate with your existing JavaScript, `immutable`
accepts plain JavaScript Arrays and Objects anywhere a method expects an
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.keyOf" id="apidoc.element.immutable.Iterable.prototype.keyOf">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keyOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keyOf = function (searchValue) {
  return this.findKey(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.keySeq" id="apidoc.element.immutable.Iterable.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return this.toSeq().map(keyMapper).toIndexedSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.keys" id="apidoc.element.immutable.Iterable.prototype.keys">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>keys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function () {
  return this.__iterator(ITERATE_KEYS);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Keep in mind, when using JS objects to construct Immutable Maps, that
JavaScript Object properties are always strings, even if written in a quote-less
shorthand, while Immutable Maps accept keys of any type.

```js
var obj = { 1: "one" };
Object.<span class="apidocCodeKeywordSpan">keys</span>(obj); // [ "1" ]
obj["1"]; // "one"
obj[1];   // "one"

var map = Immutable.fromJS(obj);
map.get("1"); // "one"
map.get(1);   // undefined
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.last" id="apidoc.element.immutable.Iterable.prototype.last">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.toSeq().reverse().first();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.lastKeyOf" id="apidoc.element.immutable.Iterable.prototype.lastKeyOf">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>lastKeyOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastKeyOf = function (searchValue) {
  return this.toKeyedSeq().reverse().keyOf(searchValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.map" id="apidoc.element.immutable.Iterable.prototype.map">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>map
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (mapper, context) {
  return reify(this, mapFactory(this, mapper, context));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Almost all of the methods on [Array][] will be found in similar form on
`Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][]
found on `Immutable.Set`, including collection operations like `forEach()`
and `map()`.

```javascript
var alpha = Immutable.Map({a:1, b:2, c:3, d:4});
alpha.<span class="apidocCodeKeywordSpan">map</span>((v, k) =&gt; k.toUpperCase()).join();
// 'A,B,C,D'
```

### Accepts raw JavaScript objects.

Designed to inter-operate with your existing JavaScript, `immutable`
accepts plain JavaScript Arrays and Objects anywhere a method expects an
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.max" id="apidoc.element.immutable.Iterable.prototype.max">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>max
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (comparator) {
  return maxFactory(this, comparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.maxBy" id="apidoc.element.immutable.Iterable.prototype.maxBy">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>maxBy
        <span class="apidocSignatureSpan">(mapper, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxBy = function (mapper, comparator) {
  return maxFactory(this, comparator, mapper);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.min" id="apidoc.element.immutable.Iterable.prototype.min">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>min
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (comparator) {
  return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.minBy" id="apidoc.element.immutable.Iterable.prototype.minBy">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>minBy
        <span class="apidocSignatureSpan">(mapper, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minBy = function (mapper, comparator) {
  return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.reduce" id="apidoc.element.immutable.Iterable.prototype.reduce">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reduce
        <span class="apidocSignatureSpan">(reducer, initialReduction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduce = function (reducer, initialReduction, context) {
  assertNotInfinite(this.size);
  var reduction;
  var useFirst;
  if (arguments.length &lt; 2) {
    useFirst = true;
  } else {
    reduction = initialReduction;
  }
  this.__iterate(function(v, k, c)  {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  });
  return reduction;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
As well as expressing logic that would otherwise seem memory-limited:

    Immutable.Range(1, Infinity)
      .skip(1000)
      .map(n =&gt; -n)
      .filter(n =&gt; n % 2 === 0)
      .take(2)
      .<span class="apidocCodeKeywordSpan">reduce</span>((r, n) =&gt; r * n, 1);
    // 1006008

Note: An iterable is always iterated in the same order, however that order may
not always be well defined, as is the case for the `Map`.


Equality treats Collections as Data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.reduceRight" id="apidoc.element.immutable.Iterable.prototype.reduceRight">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reduceRight
        <span class="apidocSignatureSpan">(reducer, initialReduction, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reduceRight = function (reducer, initialReduction, context) {
  var reversed = this.toKeyedSeq().reverse();
  return reversed.reduce.apply(reversed, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.rest" id="apidoc.element.immutable.Iterable.prototype.rest">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>rest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rest = function () {
  return this.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.reverse" id="apidoc.element.immutable.Iterable.prototype.reverse">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return reify(this, reverseFactory(this, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.skip" id="apidoc.element.immutable.Iterable.prototype.skip">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skip
        <span class="apidocSignatureSpan">(amount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (amount) {
  return this.slice(Math.max(0, amount));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
    // Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

    Immutable.Range(1, Infinity)
      .<span class="apidocCodeKeywordSpan">skip</span>(1000)
      .map(n =&gt; -n)
      .filter(n =&gt; n % 2 === 0)
      .take(2)
      .reduce((r, n) =&gt; r * n, 1);
    // 1006008

Note: An iterable is always iterated in the same order, however that order may
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.skipLast" id="apidoc.element.immutable.Iterable.prototype.skipLast">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipLast
        <span class="apidocSignatureSpan">(amount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLast = function (amount) {
  return reify(this, this.toSeq().reverse().skip(amount).reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.skipUntil" id="apidoc.element.immutable.Iterable.prototype.skipUntil">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipUntil
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipUntil = function (predicate, context) {
  return this.skipWhile(not(predicate), context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.skipWhile" id="apidoc.element.immutable.Iterable.prototype.skipWhile">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (predicate, context) {
  return reify(this, skipWhileFactory(this, predicate, context, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.slice" id="apidoc.element.immutable.Iterable.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  return reify(this, sliceFactory(this, begin, end, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.some" id="apidoc.element.immutable.Iterable.prototype.some">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>some
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (predicate, context) {
  return !this.every(not(predicate), context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.sort" id="apidoc.element.immutable.Iterable.prototype.sort">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>sort
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (comparator) {
  return reify(this, sortFactory(this, comparator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.sortBy" id="apidoc.element.immutable.Iterable.prototype.sortBy">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>sortBy
        <span class="apidocSignatureSpan">(mapper, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortBy = function (mapper, comparator) {
  return reify(this, sortFactory(this, comparator, mapper));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.take" id="apidoc.element.immutable.Iterable.prototype.take">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>take
        <span class="apidocSignatureSpan">(amount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">take = function (amount) {
  return this.slice(0, Math.max(0, amount));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

As well as expressing logic that would otherwise seem memory-limited:

    Immutable.Range(1, Infinity)
      .skip(1000)
      .map(n =&gt; -n)
      .filter(n =&gt; n % 2 === 0)
      .<span class="apidocCodeKeywordSpan">take</span>(2)
      .reduce((r, n) =&gt; r * n, 1);
    // 1006008

Note: An iterable is always iterated in the same order, however that order may
not always be well defined, as is the case for the `Map`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.takeLast" id="apidoc.element.immutable.Iterable.prototype.takeLast">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeLast
        <span class="apidocSignatureSpan">(amount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeLast = function (amount) {
  return reify(this, this.toSeq().reverse().take(amount).reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.takeUntil" id="apidoc.element.immutable.Iterable.prototype.takeUntil">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeUntil
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeUntil = function (predicate, context) {
  return this.takeWhile(not(predicate), context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.takeWhile" id="apidoc.element.immutable.Iterable.prototype.takeWhile">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>takeWhile
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">takeWhile = function (predicate, context) {
  return reify(this, takeWhileFactory(this, predicate, context));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toArray" id="apidoc.element.immutable.Iterable.prototype.toArray">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  assertNotInfinite(this.size);
  var array = new Array(this.size || 0);
  this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`.
All Immutable Iterables also implement `toJSON()` allowing them to be passed to
`JSON.stringify` directly.

```javascript
var deep = Immutable.Map({ a: 1, b: 2, c: Immutable.List.of(3, 4, 5) });
deep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }
deep.<span class="apidocCodeKeywordSpan">toArray</span>() // [ 1, 2, List [ 3, 4, 5 ] ]
deep.toJS() // { a: 1, b: 2, c: [ 3, 4, 5 ] }
JSON.stringify(deep) // '{"a":1,"b":2,"c":[3,4,5]}'
```

### Embraces ES6

`Immutable` takes advantage of features added to JavaScript in [ES6][],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toIndexedSeq" id="apidoc.element.immutable.Iterable.prototype.toIndexedSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toIndexedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toIndexedSeq = function () {
  return new ToIndexedSequence(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toJS" id="apidoc.element.immutable.Iterable.prototype.toJS">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJS = function () {
  return this.toSeq().map(
    function(value ) {return value &amp;&amp; typeof value.toJS === 'function' ? value.toJS() : value}
  ).__toJS();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
All Immutable Iterables also implement `toJSON()` allowing them to be passed to
`JSON.stringify` directly.

```javascript
var deep = Immutable.Map({ a: 1, b: 2, c: Immutable.List.of(3, 4, 5) });
deep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }
deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]
deep.<span class="apidocCodeKeywordSpan">toJS</span>() // { a: 1, b: 2, c: [ 3, 4, 5 ] }
JSON.stringify(deep) // '{"a":1,"b":2,"c":[3,4,5]}'
```

### Embraces ES6

`Immutable` takes advantage of features added to JavaScript in [ES6][],
the latest standard version of ECMAScript (JavaScript), including [Iterators][],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toJSON" id="apidoc.element.immutable.Iterable.prototype.toJSON">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toSeq().map(
    function(value ) {return value &amp;&amp; typeof value.toJSON === 'function' ? value.toJSON() : value}
  ).__toJS();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toKeyedSeq" id="apidoc.element.immutable.Iterable.prototype.toKeyedSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toKeyedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKeyedSeq = function () {
  return new ToKeyedSequence(this, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toList" id="apidoc.element.immutable.Iterable.prototype.toList">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toList = function () {
  // Use Late Binding here to solve the circular dependency.
  return List(isKeyed(this) ? this.valueSeq() : this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toMap" id="apidoc.element.immutable.Iterable.prototype.toMap">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toMap = function () {
  // Use Late Binding here to solve the circular dependency.
  return Map(this.toKeyedSeq());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toObject" id="apidoc.element.immutable.Iterable.prototype.toObject">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toObject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function () {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k)  { object[k] = v; });
  return object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
results, these operations can be extremely efficient.

```javascript
var myObject = {a:1,b:2,c:3};
Immutable.Seq(myObject).map(x =&gt; x * x).<span class="apidocCodeKeywordSpan">toObject</span>();
// { a: 1, b: 4, c: 9 }
```

Keep in mind, when using JS objects to construct Immutable Maps, that
JavaScript Object properties are always strings, even if written in a quote-less
shorthand, while Immutable Maps accept keys of any type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toOrderedMap" id="apidoc.element.immutable.Iterable.prototype.toOrderedMap">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toOrderedMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toOrderedMap = function () {
  // Use Late Binding here to solve the circular dependency.
  return OrderedMap(this.toKeyedSeq());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toOrderedSet" id="apidoc.element.immutable.Iterable.prototype.toOrderedSet">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toOrderedSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toOrderedSet = function () {
  // Use Late Binding here to solve the circular dependency.
  return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toSeq" id="apidoc.element.immutable.Iterable.prototype.toSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSeq = function () {
  return isIndexed(this) ? this.toIndexedSeq() :
    isKeyed(this) ? this.toKeyedSeq() :
    this.toSetSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9

Any collection can be converted to a lazy Seq with `.<span class="apidocCodeKeywordSpan">toSeq</span>()`.

var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();

Seq allow for the efficient chaining of sequence operations, especially when
converting to a different concrete type (such as to a JS object):

seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toSet" id="apidoc.element.immutable.Iterable.prototype.toSet">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSet = function () {
  // Use Late Binding here to solve the circular dependency.
  return Set(isKeyed(this) ? this.valueSeq() : this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toSetSeq" id="apidoc.element.immutable.Iterable.prototype.toSetSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSetSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSetSeq = function () {
  return new ToSetSequence(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toSource" id="apidoc.element.immutable.Iterable.prototype.toSource">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toSource
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSource = function () { return this.toString(); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toStack" id="apidoc.element.immutable.Iterable.prototype.toStack">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toStack
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toStack = function () {
  // Use Late Binding here to solve the circular dependency.
  return Stack(isKeyed(this) ? this.valueSeq() : this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.toString" id="apidoc.element.immutable.Iterable.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return '[Iterable]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.valueSeq" id="apidoc.element.immutable.Iterable.prototype.valueSeq">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>valueSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueSeq = function () {
  return this.toIndexedSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Iterable.prototype.values" id="apidoc.element.immutable.Iterable.prototype.values">
        function <span class="apidocSignatureSpan">immutable.Iterable.prototype.</span>values
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">values = function () {
  return this.__iterator(ITERATE_VALUES);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.List" id="apidoc.module.immutable.List">module immutable.List</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.List.List" id="apidoc.element.immutable.List.List">
        function <span class="apidocSignatureSpan">immutable.</span>List
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(value) {
  var empty = emptyList();
  if (value === null || value === undefined) {
    return empty;
  }
  if (isList(value)) {
    return value;
  }
  var iter = IndexedIterable(value);
  var size = iter.size;
  if (size === 0) {
    return empty;
  }
  assertNotInfinite(size);
  if (size &gt; 0 &amp;&amp; size &lt; SIZE) {
    return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
  }
  return empty.withMutations(function(list ) {
    list.setSize(size);
    iter.forEach(function(v, i)  {return list.set(i, v)});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.isList" id="apidoc.element.immutable.List.isList">
        function <span class="apidocSignatureSpan">immutable.List.</span>isList
        <span class="apidocSignatureSpan">(maybeList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isList(maybeList) {
  return !!(maybeList &amp;&amp; maybeList[IS_LIST_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.of" id="apidoc.element.immutable.List.of">
        function <span class="apidocSignatureSpan">immutable.List.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return this(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.List.prototype" id="apidoc.module.immutable.List.prototype">module immutable.List.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.List.prototype.__ensureOwner" id="apidoc.element.immutable.List.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  if (!ownerID) {
    this.__ownerID = ownerID;
    return this;
  }
  return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.__iterate" id="apidoc.element.immutable.List.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  var index = 0;
  var values = iterateList(this, reverse);
  var value;
  while ((value = values()) !== DONE) {
    if (fn(value, index++, this) === false) {
      break;
    }
  }
  return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.__iterator" id="apidoc.element.immutable.List.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  var index = 0;
  var values = iterateList(this, reverse);
  return new Iterator(function()  {
    var value = values();
    return value === DONE ?
      iteratorDone() :
      iteratorValue(type, index++, value);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.asImmutable" id="apidoc.element.immutable.List.prototype.asImmutable">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>asImmutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asImmutable = function () {
  return this.__ensureOwner();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.asMutable" id="apidoc.element.immutable.List.prototype.asMutable">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>asMutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asMutable = function () {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.clear" id="apidoc.element.immutable.List.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  if (this.size === 0) {
    return this;
  }
  if (this.__ownerID) {
    this.size = this._origin = this._capacity = 0;
    this._level = SHIFT;
    this._root = this._tail = null;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return emptyList();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.constructor" id="apidoc.element.immutable.List.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function List(value) {
  var empty = emptyList();
  if (value === null || value === undefined) {
    return empty;
  }
  if (isList(value)) {
    return value;
  }
  var iter = IndexedIterable(value);
  var size = iter.size;
  if (size === 0) {
    return empty;
  }
  assertNotInfinite(size);
  if (size &gt; 0 &amp;&amp; size &lt; SIZE) {
    return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
  }
  return empty.withMutations(function(list ) {
    list.setSize(size);
    iter.forEach(function(v, i)  {return list.set(i, v)});
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.delete" id="apidoc.element.immutable.List.prototype.delete">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>delete
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (index) {
  return !this.has(index) ? this :
    index === 0 ? this.shift() :
    index === this.size - 1 ? this.pop() :
    this.splice(index, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.deleteIn" id="apidoc.element.immutable.List.prototype.deleteIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>deleteIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.get" id="apidoc.element.immutable.List.prototype.get">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  index = wrapIndex(this, index);
  if (index &gt;= 0 &amp;&amp; index &lt; this.size) {
    index += this._origin;
    var node = listNodeFor(this, index);
    return node &amp;&amp; node.array[index &amp; MASK];
  }
  return notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.insert" id="apidoc.element.immutable.List.prototype.insert">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>insert
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (index, value) {
  return this.splice(index, 0, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.merge" id="apidoc.element.immutable.List.prototype.merge">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  return mergeIntoListWith(this, undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accepts plain JavaScript Arrays and Objects anywhere a method expects an
`Iterable` with no performance penalty.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
var map2 = Immutable.Map({c:10, a:20, t:30});
var obj = {d:100, o:200, g:300};
var map3 = map1.<span class="apidocCodeKeywordSpan">merge</span>(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
```

This is possible because `immutable` can treat any JavaScript Array or Object
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.mergeDeep" id="apidoc.element.immutable.List.prototype.mergeDeep">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeep = function () {
  return mergeIntoListWith(this, deepMerger, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A few power-tools allow for reading and operating on nested data. The
most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,
`Map` and `OrderedMap`.

```javascript
var nested2 = nested.<span class="apidocCodeKeywordSpan">mergeDeep</span>({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.mergeDeepIn" id="apidoc.element.immutable.List.prototype.mergeDeepIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeepIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.mergeDeep === 'function' ?
      m.mergeDeep.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.mergeDeepWith" id="apidoc.element.immutable.List.prototype.mergeDeepWith">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeDeepWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoListWith(this, deepMergerWith(merger), iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.mergeIn" id="apidoc.element.immutable.List.prototype.mergeIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.merge === 'function' ?
      m.merge.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.mergeWith" id="apidoc.element.immutable.List.prototype.mergeWith">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>mergeWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoListWith(this, merger, iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.pop" id="apidoc.element.immutable.List.prototype.pop">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  return setListBounds(this, 0, -1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.push" id="apidoc.element.immutable.List.prototype.push">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>push
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function () {
  var values = arguments;
  var oldSize = this.size;
  return this.withMutations(function(list ) {
    setListBounds(list, 0, oldSize + values.length);
    for (var ii = 0; ii &lt; values.length; ii++) {
      list.set(oldSize + ii, values[ii]);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.of(1, 2);
var list2 = list1.<span class="apidocCodeKeywordSpan">push</span>(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
assert(list4.get(0) === 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.remove" id="apidoc.element.immutable.List.prototype.remove">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>remove
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (index) {
  return !this.has(index) ? this :
    index === 0 ? this.shift() :
    index === this.size - 1 ? this.pop() :
    this.splice(index, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.removeIn" id="apidoc.element.immutable.List.prototype.removeIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>removeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.set" id="apidoc.element.immutable.List.prototype.set">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>set
        <span class="apidocSignatureSpan">(index, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (index, value) {
  return updateList(this, index, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.<span class="apidocCodeKeywordSpan">set</span>('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.setIn" id="apidoc.element.immutable.List.prototype.setIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>setIn
        <span class="apidocSignatureSpan">(keyPath, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIn = function (keyPath, v) {
  return this.updateIn(keyPath, NOT_SET, function()  {return v});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.setSize" id="apidoc.element.immutable.List.prototype.setSize">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>setSize
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setSize = function (size) {
  return setListBounds(this, 0, size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.shift" id="apidoc.element.immutable.List.prototype.shift">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  return setListBounds(this, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.slice" id="apidoc.element.immutable.List.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  var size = this.size;
  if (wholeSlice(begin, end, size)) {
    return this;
  }
  return setListBounds(
    this,
    resolveBegin(begin, size),
    resolveEnd(end, size)
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.toString" id="apidoc.element.immutable.List.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('List [', ']');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.unshift" id="apidoc.element.immutable.List.prototype.unshift">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>unshift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function () {
  var values = arguments;
  return this.withMutations(function(list ) {
    setListBounds(list, -values.length);
    for (var ii = 0; ii &lt; values.length; ii++) {
      list.set(ii, values[ii]);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.of(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.<span class="apidocCodeKeywordSpan">unshift</span>(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
assert(list4.get(0) === 1);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.update" id="apidoc.element.immutable.List.prototype.update">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>update
        <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (k, notSetValue, updater) {
  return arguments.length === 1 ?
    k(this) :
    this.updateIn([k], notSetValue, updater);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.updateIn" id="apidoc.element.immutable.List.prototype.updateIn">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>updateIn
        <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateIn = function (keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }
  var updatedValue = updateInDeepMap(
    this,
    forceIterator(keyPath),
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? undefined : updatedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nested2 = nested.mergeDeep({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.<span class="apidocCodeKeywordSpan">updateIn</span>(['a', 'b', 'd'], value =&amp;#
x3e; value + 1);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }

var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.wasAltered" id="apidoc.element.immutable.List.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this.__altered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.List.prototype.withMutations" id="apidoc.element.immutable.List.prototype.withMutations">
        function <span class="apidocSignatureSpan">immutable.List.prototype.</span>withMutations
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMutations = function (fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exactly how  `Immutable` applies complex mutations itself.

As an example, building `list2` results in the creation of 1, not 3, new
immutable Lists.

```javascript
var list1 = Immutable.List.of(1,2,3);
var list2 = list1.<span class="apidocCodeKeywordSpan">withMutations</span>(function (list) {
  list.push(4).push(5).push(6);
});
assert(list1.size === 3);
assert(list2.size === 6);
```

Note: `immutable` also provides `asMutable` and `asImmutable`, but only
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Map" id="apidoc.module.immutable.Map">module immutable.Map</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Map.Map" id="apidoc.element.immutable.Map.Map">
        function <span class="apidocSignatureSpan">immutable.</span>Map
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map(value) {
  return value === null || value === undefined ? emptyMap() :
    isMap(value) &amp;&amp; !isOrdered(value) ? value :
    emptyMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
npm install immutable
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.<span class="apidocCodeKeywordSpan">Map</span>({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.isMap" id="apidoc.element.immutable.Map.isMap">
        function <span class="apidocSignatureSpan">immutable.Map.</span>isMap
        <span class="apidocSignatureSpan">(maybeMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMap(maybeMap) {
  return !!(maybeMap &amp;&amp; maybeMap[IS_MAP_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.of" id="apidoc.element.immutable.Map.of">
        function <span class="apidocSignatureSpan">immutable.Map.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {var keyValues = SLICE$0.call(arguments, 0);
  return emptyMap().withMutations(function(map ) {
    for (var i = 0; i &lt; keyValues.length; i += 2) {
      if (i + 1 &gt;= keyValues.length) {
        throw new Error('Missing value for key: ' + keyValues[i]);
      }
      map.set(keyValues[i], keyValues[i + 1]);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Map.prototype" id="apidoc.module.immutable.Map.prototype">module immutable.Map.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.__ensureOwner" id="apidoc.element.immutable.Map.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  if (!ownerID) {
    this.__ownerID = ownerID;
    this.__altered = false;
    return this;
  }
  return makeMap(this.size, this._root, ownerID, this.__hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.__iterate" id="apidoc.element.immutable.Map.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {var this$0 = this;
  var iterations = 0;
  this._root &amp;&amp; this._root.iterate(function(entry ) {
    iterations++;
    return fn(entry[1], entry[0], this$0);
  }, reverse);
  return iterations;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.__iterator" id="apidoc.element.immutable.Map.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  return new MapIterator(this, type, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.asImmutable" id="apidoc.element.immutable.Map.prototype.asImmutable">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>asImmutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asImmutable = function () {
  return this.__ensureOwner();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.asMutable" id="apidoc.element.immutable.Map.prototype.asMutable">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>asMutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asMutable = function () {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.clear" id="apidoc.element.immutable.Map.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  if (this.size === 0) {
    return this;
  }
  if (this.__ownerID) {
    this.size = 0;
    this._root = null;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return emptyMap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.constructor" id="apidoc.element.immutable.Map.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map(value) {
  return value === null || value === undefined ? emptyMap() :
    isMap(value) &amp;&amp; !isOrdered(value) ? value :
    emptyMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.delete" id="apidoc.element.immutable.Map.prototype.delete">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>delete
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (k) {
  return updateMap(this, k, NOT_SET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.deleteIn" id="apidoc.element.immutable.Map.prototype.deleteIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>deleteIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.get" id="apidoc.element.immutable.Map.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>get
        <span class="apidocSignatureSpan">(k, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (k, notSetValue) {
  return this._root ?
    this._root.get(0, undefined, k, notSetValue) :
    notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.merge" id="apidoc.element.immutable.Map.prototype.merge">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  return mergeIntoMapWith(this, undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accepts plain JavaScript Arrays and Objects anywhere a method expects an
`Iterable` with no performance penalty.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
var map2 = Immutable.Map({c:10, a:20, t:30});
var obj = {d:100, o:200, g:300};
var map3 = map1.<span class="apidocCodeKeywordSpan">merge</span>(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
```

This is possible because `immutable` can treat any JavaScript Array or Object
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.mergeDeep" id="apidoc.element.immutable.Map.prototype.mergeDeep">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeep = function () {
  return mergeIntoMapWith(this, deepMerger, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A few power-tools allow for reading and operating on nested data. The
most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,
`Map` and `OrderedMap`.

```javascript
var nested2 = nested.<span class="apidocCodeKeywordSpan">mergeDeep</span>({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.mergeDeepIn" id="apidoc.element.immutable.Map.prototype.mergeDeepIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeepIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.mergeDeep === 'function' ?
      m.mergeDeep.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.mergeDeepWith" id="apidoc.element.immutable.Map.prototype.mergeDeepWith">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeDeepWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoMapWith(this, deepMergerWith(merger), iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.mergeIn" id="apidoc.element.immutable.Map.prototype.mergeIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.merge === 'function' ?
      m.merge.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.mergeWith" id="apidoc.element.immutable.Map.prototype.mergeWith">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>mergeWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoMapWith(this, merger, iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.remove" id="apidoc.element.immutable.Map.prototype.remove">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>remove
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (k) {
  return updateMap(this, k, NOT_SET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.removeIn" id="apidoc.element.immutable.Map.prototype.removeIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>removeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.set" id="apidoc.element.immutable.Map.prototype.set">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>set
        <span class="apidocSignatureSpan">(k, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (k, v) {
  return updateMap(this, k, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.<span class="apidocCodeKeywordSpan">set</span>('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.setIn" id="apidoc.element.immutable.Map.prototype.setIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>setIn
        <span class="apidocSignatureSpan">(keyPath, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIn = function (keyPath, v) {
  return this.updateIn(keyPath, NOT_SET, function()  {return v});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.sort" id="apidoc.element.immutable.Map.prototype.sort">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>sort
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (comparator) {
  // Late binding
  return OrderedMap(sortFactory(this, comparator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.sortBy" id="apidoc.element.immutable.Map.prototype.sortBy">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>sortBy
        <span class="apidocSignatureSpan">(mapper, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortBy = function (mapper, comparator) {
  // Late binding
  return OrderedMap(sortFactory(this, comparator, mapper));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.toString" id="apidoc.element.immutable.Map.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('Map {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.update" id="apidoc.element.immutable.Map.prototype.update">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>update
        <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (k, notSetValue, updater) {
  return arguments.length === 1 ?
    k(this) :
    this.updateIn([k], notSetValue, updater);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.updateIn" id="apidoc.element.immutable.Map.prototype.updateIn">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>updateIn
        <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateIn = function (keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }
  var updatedValue = updateInDeepMap(
    this,
    forceIterator(keyPath),
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? undefined : updatedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nested2 = nested.mergeDeep({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.<span class="apidocCodeKeywordSpan">updateIn</span>(['a', 'b', 'd'], value =&amp;#
x3e; value + 1);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }

var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.wasAltered" id="apidoc.element.immutable.Map.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this.__altered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Map.prototype.withMutations" id="apidoc.element.immutable.Map.prototype.withMutations">
        function <span class="apidocSignatureSpan">immutable.Map.prototype.</span>withMutations
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMutations = function (fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exactly how  `Immutable` applies complex mutations itself.

As an example, building `list2` results in the creation of 1, not 3, new
immutable Lists.

```javascript
var list1 = Immutable.List.of(1,2,3);
var list2 = list1.<span class="apidocCodeKeywordSpan">withMutations</span>(function (list) {
  list.push(4).push(5).push(6);
});
assert(list1.size === 3);
assert(list2.size === 6);
```

Note: `immutable` also provides `asMutable` and `asImmutable`, but only
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.OrderedMap" id="apidoc.module.immutable.OrderedMap">module immutable.OrderedMap</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.OrderedMap" id="apidoc.element.immutable.OrderedMap.OrderedMap">
        function <span class="apidocSignatureSpan">immutable.</span>OrderedMap
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedMap(value) {
  return value === null || value === undefined ? emptyOrderedMap() :
    isOrderedMap(value) ? value :
    emptyOrderedMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.isOrderedMap" id="apidoc.element.immutable.OrderedMap.isOrderedMap">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.</span>isOrderedMap
        <span class="apidocSignatureSpan">(maybeOrderedMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) &amp;&amp; isOrdered(maybeOrderedMap);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.of" id="apidoc.element.immutable.OrderedMap.of">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return this(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.OrderedMap.prototype" id="apidoc.module.immutable.OrderedMap.prototype">module immutable.OrderedMap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.__ensureOwner" id="apidoc.element.immutable.OrderedMap.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newMap = this._map.__ensureOwner(ownerID);
  var newList = this._list.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._map = newMap;
    this._list = newList;
    return this;
  }
  return makeOrderedMap(newMap, newList, ownerID, this.__hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.__iterate" id="apidoc.element.immutable.OrderedMap.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {var this$0 = this;
  return this._list.__iterate(
    function(entry ) {return entry &amp;&amp; fn(entry[1], entry[0], this$0)},
    reverse
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.__iterator" id="apidoc.element.immutable.OrderedMap.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  return this._list.fromEntrySeq().__iterator(type, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.clear" id="apidoc.element.immutable.OrderedMap.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  if (this.size === 0) {
    return this;
  }
  if (this.__ownerID) {
    this.size = 0;
    this._map.clear();
    this._list.clear();
    return this;
  }
  return emptyOrderedMap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.constructor" id="apidoc.element.immutable.OrderedMap.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedMap(value) {
  return value === null || value === undefined ? emptyOrderedMap() :
    isOrderedMap(value) ? value :
    emptyOrderedMap().withMutations(function(map ) {
      var iter = KeyedIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k)  {return map.set(k, v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.delete" id="apidoc.element.immutable.OrderedMap.prototype.delete">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>delete
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (k) {
  return updateOrderedMap(this, k, NOT_SET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.get" id="apidoc.element.immutable.OrderedMap.prototype.get">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>get
        <span class="apidocSignatureSpan">(k, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (k, notSetValue) {
  var index = this._map.get(k);
  return index !== undefined ? this._list.get(index)[1] : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.remove" id="apidoc.element.immutable.OrderedMap.prototype.remove">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>remove
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (k) {
  return updateOrderedMap(this, k, NOT_SET);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.set" id="apidoc.element.immutable.OrderedMap.prototype.set">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>set
        <span class="apidocSignatureSpan">(k, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (k, v) {
  return updateOrderedMap(this, k, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.<span class="apidocCodeKeywordSpan">set</span>('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.toString" id="apidoc.element.immutable.OrderedMap.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('OrderedMap {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedMap.prototype.wasAltered" id="apidoc.element.immutable.OrderedMap.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.OrderedMap.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this._map.wasAltered() || this._list.wasAltered();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.OrderedSet" id="apidoc.module.immutable.OrderedSet">module immutable.OrderedSet</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.OrderedSet" id="apidoc.element.immutable.OrderedSet.OrderedSet">
        function <span class="apidocSignatureSpan">immutable.</span>OrderedSet
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedSet(value) {
  return value === null || value === undefined ? emptyOrderedSet() :
    isOrderedSet(value) ? value :
    emptyOrderedSet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.fromKeys" id="apidoc.element.immutable.OrderedSet.fromKeys">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>fromKeys
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromKeys = function (value) {
  return this(KeyedIterable(value).keySeq());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.isOrderedSet" id="apidoc.element.immutable.OrderedSet.isOrderedSet">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>isOrderedSet
        <span class="apidocSignatureSpan">(maybeOrderedSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) &amp;&amp; isOrdered(maybeOrderedSet);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.of" id="apidoc.element.immutable.OrderedSet.of">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return this(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.OrderedSet.prototype" id="apidoc.module.immutable.OrderedSet.prototype">module immutable.OrderedSet.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.prototype.__empty" id="apidoc.element.immutable.OrderedSet.prototype.__empty">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>__empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.prototype.__make" id="apidoc.element.immutable.OrderedSet.prototype.__make">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>__make
        <span class="apidocSignatureSpan">(map, ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeOrderedSet(map, ownerID) {
  var set = Object.create(OrderedSetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.prototype.constructor" id="apidoc.element.immutable.OrderedSet.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OrderedSet(value) {
  return value === null || value === undefined ? emptyOrderedSet() :
    isOrderedSet(value) ? value :
    emptyOrderedSet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.OrderedSet.prototype.toString" id="apidoc.element.immutable.OrderedSet.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.OrderedSet.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('OrderedSet {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Range" id="apidoc.module.immutable.Range">module immutable.Range</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Range.Range" id="apidoc.element.immutable.Range.Range">
        function <span class="apidocSignatureSpan">immutable.</span>Range
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    return new Range(start, end, step);
  }
  invariant(step !== 0, 'Cannot step a Range by 0');
  start = start || 0;
  if (end === undefined) {
    end = Infinity;
  }
  step = step === undefined ? 1 : Math.abs(step);
  if (end &lt; start) {
    step = -step;
  }
  this._start = start;
  this._end = end;
  this._step = step;
  this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
  if (this.size === 0) {
    if (EMPTY_RANGE) {
      return EMPTY_RANGE;
    }
    EMPTY_RANGE = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
converting to a different concrete type (such as to a JS object):

seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

Immutable.<span class="apidocCodeKeywordSpan">Range</span>(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
  .filter(n =&gt; n % 2 === 0)
  .take(2)
  .reduce((r, n) =&gt; r * n, 1);
// 1006008
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Range.prototype" id="apidoc.module.immutable.Range.prototype">module immutable.Range.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.__iterate" id="apidoc.element.immutable.Range.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  var maxIndex = this.size - 1;
  var step = this._step;
  var value = reverse ? this._start + maxIndex * step : this._start;
  for (var ii = 0; ii &lt;= maxIndex; ii++) {
    if (fn(value, ii, this) === false) {
      return ii + 1;
    }
    value += reverse ? -step : step;
  }
  return ii;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.__iterator" id="apidoc.element.immutable.Range.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  var maxIndex = this.size - 1;
  var step = this._step;
  var value = reverse ? this._start + maxIndex * step : this._start;
  var ii = 0;
  return new Iterator(function()  {
    var v = value;
    value += reverse ? -step : step;
    return ii &gt; maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.constructor" id="apidoc.element.immutable.Range.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>constructor
        <span class="apidocSignatureSpan">(start, end, step)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Range(start, end, step) {
  if (!(this instanceof Range)) {
    return new Range(start, end, step);
  }
  invariant(step !== 0, 'Cannot step a Range by 0');
  start = start || 0;
  if (end === undefined) {
    end = Infinity;
  }
  step = step === undefined ? 1 : Math.abs(step);
  if (end &lt; start) {
    step = -step;
  }
  this._start = start;
  this._end = end;
  this._step = step;
  this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
  if (this.size === 0) {
    if (EMPTY_RANGE) {
      return EMPTY_RANGE;
    }
    EMPTY_RANGE = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.equals" id="apidoc.element.immutable.Range.prototype.equals">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return other instanceof Range ?
    this._start === other._start &amp;&amp;
    this._end === other._end &amp;&amp;
    this._step === other._step :
    deepEqual(this, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
interested in doing work when something has changed, you can use equality.

Immutable collections should be treated as *values* rather than *objects*. While
objects represents some thing which could change over time, a value represents
the state of that thing at a particular instance of time. This principle is most
important to understanding the appropriate use of immutable data. In order to
treat Immutable.js collections as values, it's important to use the
`Immutable.is()` function or `.<span class="apidocCodeKeywordSpan">equals</span>()` method to determine value equality
instead of the `===` operator which determines object reference identity.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 2);
assert(map1.equals(map2) === true);
var map3 = map1.set('b', 50);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.get" id="apidoc.element.immutable.Range.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  return this.has(index) ?
    this._start + wrapIndex(this, index) * this._step :
    notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.includes" id="apidoc.element.immutable.Range.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>includes
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (searchValue) {
  var possibleIndex = (searchValue - this._start) / this._step;
  return possibleIndex &gt;= 0 &amp;&amp;
    possibleIndex &lt; this.size &amp;&amp;
    possibleIndex === Math.floor(possibleIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.indexOf" id="apidoc.element.immutable.Range.prototype.indexOf">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchValue) {
  var offsetValue = searchValue - this._start;
  if (offsetValue % this._step === 0) {
    var index = offsetValue / this._step;
    if (index &gt;= 0 &amp;&amp; index &lt; this.size) {
      return index
    }
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.lastIndexOf" id="apidoc.element.immutable.Range.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchValue) {
  return this.indexOf(searchValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.slice" id="apidoc.element.immutable.Range.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  if (wholeSlice(begin, end, this.size)) {
    return this;
  }
  begin = resolveBegin(begin, this.size);
  end = resolveEnd(end, this.size);
  if (end &lt;= begin) {
    return new Range(0, 0);
  }
  return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Range.prototype.toString" id="apidoc.element.immutable.Range.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Range.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  if (this.size === 0) {
    return 'Range []';
  }
  return 'Range [ ' +
    this._start + '...' + this._end +
    (this._step !== 1 ? ' by ' + this._step : '') +
  ' ]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Record" id="apidoc.module.immutable.Record">module immutable.Record</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Record.Record" id="apidoc.element.immutable.Record.Record">
        function <span class="apidocSignatureSpan">immutable.</span>Record
        <span class="apidocSignatureSpan">(defaultValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      setProps(RecordTypePrototype, keys);
      RecordTypePrototype.size = keys.length;
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
    }
    this._map = Map(values);
  };

  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;

  return RecordType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Record.prototype" id="apidoc.module.immutable.Record.prototype">module immutable.Record.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.__ensureOwner" id="apidoc.element.immutable.Record.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newMap = this._map &amp;&amp; this._map.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._map = newMap;
    return this;
  }
  return makeRecord(this, newMap, ownerID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.__iterate" id="apidoc.element.immutable.Record.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {var this$0 = this;
  return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.__iterator" id="apidoc.element.immutable.Record.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {var this$0 = this;
  return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.asImmutable" id="apidoc.element.immutable.Record.prototype.asImmutable">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>asImmutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asImmutable = function () {
  return this.__ensureOwner();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.asMutable" id="apidoc.element.immutable.Record.prototype.asMutable">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>asMutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asMutable = function () {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.clear" id="apidoc.element.immutable.Record.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  if (this.__ownerID) {
    this._map &amp;&amp; this._map.clear();
    return this;
  }
  var RecordType = this.constructor;
  return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.constructor" id="apidoc.element.immutable.Record.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>constructor
        <span class="apidocSignatureSpan">(defaultValues, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      setProps(RecordTypePrototype, keys);
      RecordTypePrototype.size = keys.length;
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
    }
    this._map = Map(values);
  };

  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;

  return RecordType;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.delete" id="apidoc.element.immutable.Record.prototype.delete">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>delete
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (k) {
  if (!this.has(k)) {
    return this;
  }
  var newMap = this._map &amp;&amp; this._map.remove(k);
  if (this.__ownerID || newMap === this._map) {
    return this;
  }
  return makeRecord(this, newMap);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.deleteIn" id="apidoc.element.immutable.Record.prototype.deleteIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>deleteIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.get" id="apidoc.element.immutable.Record.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>get
        <span class="apidocSignatureSpan">(k, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var defaultVal = this._defaultValues[k];
  return this._map ? this._map.get(k, defaultVal) : defaultVal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.has" id="apidoc.element.immutable.Record.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>has
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (k) {
  return this._defaultValues.hasOwnProperty(k);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.merge" id="apidoc.element.immutable.Record.prototype.merge">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  return mergeIntoMapWith(this, undefined, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accepts plain JavaScript Arrays and Objects anywhere a method expects an
`Iterable` with no performance penalty.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
var map2 = Immutable.Map({c:10, a:20, t:30});
var obj = {d:100, o:200, g:300};
var map3 = map1.<span class="apidocCodeKeywordSpan">merge</span>(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
```

This is possible because `immutable` can treat any JavaScript Array or Object
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.mergeDeep" id="apidoc.element.immutable.Record.prototype.mergeDeep">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeep = function () {
  return mergeIntoMapWith(this, deepMerger, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A few power-tools allow for reading and operating on nested data. The
most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,
`Map` and `OrderedMap`.

```javascript
var nested2 = nested.<span class="apidocCodeKeywordSpan">mergeDeep</span>({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.mergeDeepIn" id="apidoc.element.immutable.Record.prototype.mergeDeepIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeepIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.mergeDeep === 'function' ?
      m.mergeDeep.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.mergeDeepWith" id="apidoc.element.immutable.Record.prototype.mergeDeepWith">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeDeepWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoMapWith(this, deepMergerWith(merger), iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.mergeIn" id="apidoc.element.immutable.Record.prototype.mergeIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeIn = function (keyPath) {var iters = SLICE$0.call(arguments, 1);
  return this.updateIn(
    keyPath,
    emptyMap(),
    function(m ) {return typeof m.merge === 'function' ?
      m.merge.apply(m, iters) :
      iters[iters.length - 1]}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.mergeWith" id="apidoc.element.immutable.Record.prototype.mergeWith">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>mergeWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return mergeIntoMapWith(this, merger, iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.remove" id="apidoc.element.immutable.Record.prototype.remove">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>remove
        <span class="apidocSignatureSpan">(k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (k) {
  if (!this.has(k)) {
    return this;
  }
  var newMap = this._map &amp;&amp; this._map.remove(k);
  if (this.__ownerID || newMap === this._map) {
    return this;
  }
  return makeRecord(this, newMap);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.removeIn" id="apidoc.element.immutable.Record.prototype.removeIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>removeIn
        <span class="apidocSignatureSpan">(keyPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeIn = function (keyPath) {
  return this.updateIn(keyPath, function()  {return NOT_SET});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.set" id="apidoc.element.immutable.Record.prototype.set">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>set
        <span class="apidocSignatureSpan">(k, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (k, v) {
  if (!this.has(k)) {
    throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
  }
  if (this._map &amp;&amp; !this._map.has(k)) {
    var defaultVal = this._defaultValues[k];
    if (v === defaultVal) {
      return this;
    }
  }
  var newMap = this._map &amp;&amp; this._map.set(k, v);
  if (this.__ownerID || newMap === this._map) {
    return this;
  }
  return makeRecord(this, newMap);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.<span class="apidocCodeKeywordSpan">set</span>('b', 50);
map1.get('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.setIn" id="apidoc.element.immutable.Record.prototype.setIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>setIn
        <span class="apidocSignatureSpan">(keyPath, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setIn = function (keyPath, v) {
  return this.updateIn(keyPath, NOT_SET, function()  {return v});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.toString" id="apidoc.element.immutable.Record.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString(recordName(this) + ' {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.update" id="apidoc.element.immutable.Record.prototype.update">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>update
        <span class="apidocSignatureSpan">(k, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (k, notSetValue, updater) {
  return arguments.length === 1 ?
    k(this) :
    this.updateIn([k], notSetValue, updater);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.updateIn" id="apidoc.element.immutable.Record.prototype.updateIn">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>updateIn
        <span class="apidocSignatureSpan">(keyPath, notSetValue, updater)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateIn = function (keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }
  var updatedValue = updateInDeepMap(
    this,
    forceIterator(keyPath),
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? undefined : updatedValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nested2 = nested.mergeDeep({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.<span class="apidocCodeKeywordSpan">updateIn</span>(['a', 'b', 'd'], value =&amp;#
x3e; value + 1);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }

var nested4 = nested3.updateIn(['a', 'b', 'c'], list =&gt; list.push(6));
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.wasAltered" id="apidoc.element.immutable.Record.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this._map.wasAltered();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Record.prototype.withMutations" id="apidoc.element.immutable.Record.prototype.withMutations">
        function <span class="apidocSignatureSpan">immutable.Record.prototype.</span>withMutations
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMutations = function (fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exactly how  `Immutable` applies complex mutations itself.

As an example, building `list2` results in the creation of 1, not 3, new
immutable Lists.

```javascript
var list1 = Immutable.List.of(1,2,3);
var list2 = list1.<span class="apidocCodeKeywordSpan">withMutations</span>(function (list) {
  list.push(4).push(5).push(6);
});
assert(list1.size === 3);
assert(list2.size === 6);
```

Note: `immutable` also provides `asMutable` and `asImmutable`, but only
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Repeat" id="apidoc.module.immutable.Repeat">module immutable.Repeat</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Repeat.Repeat" id="apidoc.element.immutable.Repeat.Repeat">
        function <span class="apidocSignatureSpan">immutable.</span>Repeat
        <span class="apidocSignatureSpan">(value, times)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Repeat(value, times) {
  if (!(this instanceof Repeat)) {
    return new Repeat(value, times);
  }
  this._value = value;
  this.size = times === undefined ? Infinity : Math.max(0, times);
  if (this.size === 0) {
    if (EMPTY_REPEAT) {
      return EMPTY_REPEAT;
    }
    EMPTY_REPEAT = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Repeat.prototype" id="apidoc.module.immutable.Repeat.prototype">module immutable.Repeat.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.__iterate" id="apidoc.element.immutable.Repeat.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  for (var ii = 0; ii &lt; this.size; ii++) {
    if (fn(this._value, ii, this) === false) {
      return ii + 1;
    }
  }
  return ii;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.__iterator" id="apidoc.element.immutable.Repeat.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {var this$0 = this;
  var ii = 0;
  return new Iterator(function()
    {return ii &lt; this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.constructor" id="apidoc.element.immutable.Repeat.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value, times)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Repeat(value, times) {
  if (!(this instanceof Repeat)) {
    return new Repeat(value, times);
  }
  this._value = value;
  this.size = times === undefined ? Infinity : Math.max(0, times);
  if (this.size === 0) {
    if (EMPTY_REPEAT) {
      return EMPTY_REPEAT;
    }
    EMPTY_REPEAT = this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.equals" id="apidoc.element.immutable.Repeat.prototype.equals">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (other) {
  return other instanceof Repeat ?
    is(this._value, other._value) :
    deepEqual(other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
interested in doing work when something has changed, you can use equality.

Immutable collections should be treated as *values* rather than *objects*. While
objects represents some thing which could change over time, a value represents
the state of that thing at a particular instance of time. This principle is most
important to understanding the appropriate use of immutable data. In order to
treat Immutable.js collections as values, it's important to use the
`Immutable.is()` function or `.<span class="apidocCodeKeywordSpan">equals</span>()` method to determine value equality
instead of the `===` operator which determines object reference identity.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 2);
assert(map1.equals(map2) === true);
var map3 = map1.set('b', 50);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.get" id="apidoc.element.immutable.Repeat.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  return this.has(index) ? this._value : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.includes" id="apidoc.element.immutable.Repeat.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>includes
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (searchValue) {
  return is(this._value, searchValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.indexOf" id="apidoc.element.immutable.Repeat.prototype.indexOf">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchValue) {
  if (is(this._value, searchValue)) {
    return 0;
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.lastIndexOf" id="apidoc.element.immutable.Repeat.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchValue) {
  if (is(this._value, searchValue)) {
    return this.size;
  }
  return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.reverse" id="apidoc.element.immutable.Repeat.prototype.reverse">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.slice" id="apidoc.element.immutable.Repeat.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  var size = this.size;
  return wholeSlice(begin, end, size) ? this :
    new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Repeat.prototype.toString" id="apidoc.element.immutable.Repeat.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Repeat.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  if (this.size === 0) {
    return 'Repeat []';
  }
  return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq" id="apidoc.module.immutable.Seq">module immutable.Seq</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Seq" id="apidoc.element.immutable.Seq.Seq">
        function <span class="apidocSignatureSpan">immutable.</span>Seq
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(value) {
  return value === null || value === undefined ? emptySequence() :
    isIterable(value) ? value.toSeq() : seqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
results, these operations can be extremely efficient.

```javascript
var myObject = {a:1,b:2,c:3};
Immutable.<span class="apidocCodeKeywordSpan">Seq</span>(myObject).map(x =&gt; x * x).toObject();
// { a: 1, b: 4, c: 9 }
```

Keep in mind, when using JS objects to construct Immutable Maps, that
JavaScript Object properties are always strings, even if written in a quote-less
shorthand, while Immutable Maps accept keys of any type.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed" id="apidoc.element.immutable.Seq.Indexed">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Indexed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedSeq(value) {
  return value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed" id="apidoc.element.immutable.Seq.Keyed">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Keyed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedSeq(value) {
  return value === null || value === undefined ?
    emptySequence().toKeyedSeq() :
    isIterable(value) ?
      (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
      keyedSeqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set" id="apidoc.element.immutable.Seq.Set">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetSeq(value) {
  return (
    value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value
  ).toSetSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.isSeq" id="apidoc.element.immutable.Seq.isSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>isSeq
        <span class="apidocSignatureSpan">(maybeSeq)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSeq(maybeSeq) {
  return !!(maybeSeq &amp;&amp; maybeSeq[IS_SEQ_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.of" id="apidoc.element.immutable.Seq.of">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return Seq(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Indexed" id="apidoc.module.immutable.Seq.Indexed">module immutable.Seq.Indexed</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.Indexed" id="apidoc.element.immutable.Seq.Indexed.Indexed">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Indexed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedSeq(value) {
  return value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.of" id="apidoc.element.immutable.Seq.Indexed.of">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return IndexedSeq(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Indexed.prototype" id="apidoc.module.immutable.Seq.Indexed.prototype">module immutable.Seq.Indexed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.__iterate" id="apidoc.element.immutable.Seq.Indexed.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  return seqIterate(this, fn, reverse, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.__iterator" id="apidoc.element.immutable.Seq.Indexed.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  return seqIterator(this, type, reverse, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.constructor" id="apidoc.element.immutable.Seq.Indexed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IndexedIterable(value) {
  return isIndexed(value) ? value : IndexedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.filter" id="apidoc.element.immutable.Seq.Indexed.prototype.filter">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (predicate, context) {
  return reify(this, filterFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
**Seq is lazy** â€” Seq does as little work as necessary to respond to any
method call.

For example, the following does not perform any work, because the resulting
Seq is never used:

var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
  .<span class="apidocCodeKeywordSpan">filter</span>(x =&gt; x % 2).map(x =&gt; x * x);

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.findIndex" id="apidoc.element.immutable.Seq.Indexed.prototype.findIndex">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findIndex = function (predicate, context) {
  var entry = this.findEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.findLastIndex" id="apidoc.element.immutable.Seq.Indexed.prototype.findLastIndex">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>findLastIndex
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLastIndex = function (predicate, context) {
  var entry = this.findLastEntry(predicate, context);
  return entry ? entry[0] : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.first" id="apidoc.element.immutable.Seq.Indexed.prototype.first">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>first
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">first = function () {
  return this.get(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.flatten" id="apidoc.element.immutable.Seq.Indexed.prototype.flatten">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>flatten
        <span class="apidocSignatureSpan">(depth)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (depth) {
  return reify(this, flattenFactory(this, depth, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.get" id="apidoc.element.immutable.Seq.Indexed.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  index = wrapIndex(this, index);
  return (index &lt; 0 || (this.size === Infinity ||
      (this.size !== undefined &amp;&amp; index &gt; this.size))) ?
    notSetValue :
    this.find(function(_, key)  {return key === index}, undefined, notSetValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.has" id="apidoc.element.immutable.Seq.Indexed.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>has
        <span class="apidocSignatureSpan">(index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (index) {
  index = wrapIndex(this, index);
  return index &gt;= 0 &amp;&amp; (this.size !== undefined ?
    this.size === Infinity || index &lt; this.size :
    this.indexOf(index) !== -1
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.indexOf" id="apidoc.element.immutable.Seq.Indexed.prototype.indexOf">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOf = function (searchValue) {
  var key = this.keyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.interleave" id="apidoc.element.immutable.Seq.Indexed.prototype.interleave">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>interleave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interleave = function () {
  var iterables = [this].concat(arrCopy(arguments));
  var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
  var interleaved = zipped.flatten(true);
  if (zipped.size) {
    interleaved.size = zipped.size * iterables.length;
  }
  return reify(this, interleaved);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.interpose" id="apidoc.element.immutable.Seq.Indexed.prototype.interpose">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>interpose
        <span class="apidocSignatureSpan">(separator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpose = function (separator) {
  return reify(this, interposeFactory(this, separator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.keySeq" id="apidoc.element.immutable.Seq.Indexed.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return Range(0, this.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.last" id="apidoc.element.immutable.Seq.Indexed.prototype.last">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>last
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">last = function () {
  return this.get(-1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.lastIndexOf" id="apidoc.element.immutable.Seq.Indexed.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lastIndexOf = function (searchValue) {
  var key = this.lastKeyOf(searchValue);
  return key === undefined ? -1 : key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.reverse" id="apidoc.element.immutable.Seq.Indexed.prototype.reverse">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>reverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverse = function () {
  return reify(this, reverseFactory(this, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.skipWhile" id="apidoc.element.immutable.Seq.Indexed.prototype.skipWhile">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipWhile = function (predicate, context) {
  return reify(this, skipWhileFactory(this, predicate, context, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.slice" id="apidoc.element.immutable.Seq.Indexed.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  return reify(this, sliceFactory(this, begin, end, false));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.splice" id="apidoc.element.immutable.Seq.Indexed.prototype.splice">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>splice
        <span class="apidocSignatureSpan">(index, removeNum)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">splice = function (index, removeNum) {
  var numArgs = arguments.length;
  removeNum = Math.max(removeNum | 0, 0);
  if (numArgs === 0 || (numArgs === 2 &amp;&amp; !removeNum)) {
    return this;
  }
  // If index is negative, it should resolve relative to the size of the
  // collection. However size may be expensive to compute if not cached, so
  // only call count() if the number is in fact negative.
  index = resolveBegin(index, index &lt; 0 ? this.count() : this.size);
  var spliced = this.slice(0, index);
  return reify(
    this,
    numArgs === 1 ?
      spliced :
      spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.toIndexedSeq" id="apidoc.element.immutable.Seq.Indexed.prototype.toIndexedSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toIndexedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toIndexedSeq = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.toKeyedSeq" id="apidoc.element.immutable.Seq.Indexed.prototype.toKeyedSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toKeyedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKeyedSeq = function () {
  return new ToKeyedSequence(this, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.toString" id="apidoc.element.immutable.Seq.Indexed.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('Seq [', ']');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.zip" id="apidoc.element.immutable.Seq.Indexed.prototype.zip">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zip = function () {
  var iterables = [this].concat(arrCopy(arguments));
  return reify(this, zipWithFactory(this, defaultZipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Indexed.prototype.zipWith" id="apidoc.element.immutable.Seq.Indexed.prototype.zipWith">
        function <span class="apidocSignatureSpan">immutable.Seq.Indexed.prototype.</span>zipWith
        <span class="apidocSignatureSpan">(zipper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zipWith = function (zipper) {
  var iterables = arrCopy(arguments);
  iterables[0] = this;
  return reify(this, zipWithFactory(this, zipper, iterables));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Keyed" id="apidoc.module.immutable.Seq.Keyed">module immutable.Seq.Keyed</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.Keyed" id="apidoc.element.immutable.Seq.Keyed.Keyed">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Keyed
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedSeq(value) {
  return value === null || value === undefined ?
    emptySequence().toKeyedSeq() :
    isIterable(value) ?
      (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
      keyedSeqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Keyed.prototype" id="apidoc.module.immutable.Seq.Keyed.prototype">module immutable.Seq.Keyed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.__toJS" id="apidoc.element.immutable.Seq.Keyed.prototype.__toJS">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>__toJS
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toJS = function () {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k)  { object[k] = v; });
  return object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.__toStringMapper" id="apidoc.element.immutable.Seq.Keyed.prototype.__toStringMapper">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>__toStringMapper
        <span class="apidocSignatureSpan">(v, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__toStringMapper = function (v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.constructor" id="apidoc.element.immutable.Seq.Keyed.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KeyedIterable(value) {
  return isKeyed(value) ? value : KeyedSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.flip" id="apidoc.element.immutable.Seq.Keyed.prototype.flip">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>flip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flip = function () {
  return reify(this, flipFactory(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Any collection can be converted to a lazy Seq with `.toSeq()`.

var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();

Seq allow for the efficient chaining of sequence operations, especially when
converting to a different concrete type (such as to a JS object):

seq.<span class="apidocCodeKeywordSpan">flip</span>().map(key =&gt; key.toUpperCase()).flip().toObject();
// Map { A: 1, B: 1, C: 1 }

As well as expressing logic that would otherwise seem memory-limited:

Immutable.Range(1, Infinity)
  .skip(1000)
  .map(n =&gt; -n)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.mapEntries" id="apidoc.element.immutable.Seq.Keyed.prototype.mapEntries">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>mapEntries
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapEntries = function (mapper, context) {var this$0 = this;
  var iterations = 0;
  return reify(this,
    this.toSeq().map(
      function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
    ).fromEntrySeq()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.mapKeys" id="apidoc.element.immutable.Seq.Keyed.prototype.mapKeys">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>mapKeys
        <span class="apidocSignatureSpan">(mapper, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapKeys = function (mapper, context) {var this$0 = this;
  return reify(this,
    this.toSeq().flip().map(
      function(k, v)  {return mapper.call(context, k, v, this$0)}
    ).flip()
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Keyed.prototype.toKeyedSeq" id="apidoc.element.immutable.Seq.Keyed.prototype.toKeyedSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Keyed.prototype.</span>toKeyedSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKeyedSeq = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Set" id="apidoc.module.immutable.Seq.Set">module immutable.Seq.Set</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.Set" id="apidoc.element.immutable.Seq.Set.Set">
        function <span class="apidocSignatureSpan">immutable.Seq.</span>Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetSeq(value) {
  return (
    value === null || value === undefined ? emptySequence() :
    !isIterable(value) ? indexedSeqFromValue(value) :
    isKeyed(value) ? value.entrySeq() : value
  ).toSetSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.of" id="apidoc.element.immutable.Seq.Set.of">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return SetSeq(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.Set.prototype" id="apidoc.module.immutable.Seq.Set.prototype">module immutable.Seq.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.constructor" id="apidoc.element.immutable.Seq.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SetIterable(value) {
  return isIterable(value) &amp;&amp; !isAssociative(value) ? value : SetSeq(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.contains" id="apidoc.element.immutable.Seq.Set.prototype.contains">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>contains
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.get" id="apidoc.element.immutable.Seq.Set.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>get
        <span class="apidocSignatureSpan">(value, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (value, notSetValue) {
  return this.has(value) ? value : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.has" id="apidoc.element.immutable.Seq.Set.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>has
        <span class="apidocSignatureSpan">(searchValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (searchValue) {
  return this.some(function(value ) {return is(value, searchValue)});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.includes" id="apidoc.element.immutable.Seq.Set.prototype.includes">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>includes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">includes = function (value) {
  return this.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.keySeq" id="apidoc.element.immutable.Seq.Set.prototype.keySeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>keySeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keySeq = function () {
  return this.valueSeq();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.Set.prototype.toSetSeq" id="apidoc.element.immutable.Seq.Set.prototype.toSetSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.Set.prototype.</span>toSetSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSetSeq = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Seq.prototype" id="apidoc.module.immutable.Seq.prototype">module immutable.Seq.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.__iterate" id="apidoc.element.immutable.Seq.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  return seqIterate(this, fn, reverse, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.__iterator" id="apidoc.element.immutable.Seq.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  return seqIterator(this, type, reverse, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.cacheResult" id="apidoc.element.immutable.Seq.prototype.cacheResult">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>cacheResult
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cacheResult = function () {
  if (!this._cache &amp;&amp; this.__iterateUncached) {
    this._cache = this.entrySeq().toArray();
    this.size = this._cache.length;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.constructor" id="apidoc.element.immutable.Seq.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Seq(value) {
  return value === null || value === undefined ? emptySequence() :
    isIterable(value) ? value.toSeq() : seqFromValue(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.toSeq" id="apidoc.element.immutable.Seq.prototype.toSeq">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>toSeq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSeq = function () {
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Once the Seq is used, it performs only the work necessary. In this
example, no intermediate arrays are ever created, filter is called three times,
and map is only called twice:

console.log(oddSquares.get(1)); // 9

Any collection can be converted to a lazy Seq with `.<span class="apidocCodeKeywordSpan">toSeq</span>()`.

var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();

Seq allow for the efficient chaining of sequence operations, especially when
converting to a different concrete type (such as to a JS object):

seq.flip().map(key =&gt; key.toUpperCase()).flip().toObject();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Seq.prototype.toString" id="apidoc.element.immutable.Seq.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Seq.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('Seq {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Set" id="apidoc.module.immutable.Set">module immutable.Set</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Set.Set" id="apidoc.element.immutable.Set.Set">
        function <span class="apidocSignatureSpan">immutable.</span>Set
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(value) {
  return value === null || value === undefined ? emptySet() :
    isSet(value) &amp;&amp; !isOrdered(value) ? value :
    emptySet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.fromKeys" id="apidoc.element.immutable.Set.fromKeys">
        function <span class="apidocSignatureSpan">immutable.Set.</span>fromKeys
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromKeys = function (value) {
  return this(KeyedIterable(value).keySeq());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.isSet" id="apidoc.element.immutable.Set.isSet">
        function <span class="apidocSignatureSpan">immutable.Set.</span>isSet
        <span class="apidocSignatureSpan">(maybeSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSet(maybeSet) {
  return !!(maybeSet &amp;&amp; maybeSet[IS_SET_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.of" id="apidoc.element.immutable.Set.of">
        function <span class="apidocSignatureSpan">immutable.Set.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return this(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Set.prototype" id="apidoc.module.immutable.Set.prototype">module immutable.Set.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.__empty" id="apidoc.element.immutable.Set.prototype.__empty">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.__ensureOwner" id="apidoc.element.immutable.Set.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newMap = this._map.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._map = newMap;
    return this;
  }
  return this.__make(newMap, ownerID);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.__iterate" id="apidoc.element.immutable.Set.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {var this$0 = this;
  return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.__iterator" id="apidoc.element.immutable.Set.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.__make" id="apidoc.element.immutable.Set.prototype.__make">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>__make
        <span class="apidocSignatureSpan">(map, ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.add" id="apidoc.element.immutable.Set.prototype.add">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>add
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (value) {
  return updateSet(this, this._map.set(value, true));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.asImmutable" id="apidoc.element.immutable.Set.prototype.asImmutable">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>asImmutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asImmutable = function () {
  return this.__ensureOwner();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.asMutable" id="apidoc.element.immutable.Set.prototype.asMutable">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>asMutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asMutable = function () {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.clear" id="apidoc.element.immutable.Set.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  return updateSet(this, this._map.clear());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.constructor" id="apidoc.element.immutable.Set.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set(value) {
  return value === null || value === undefined ? emptySet() :
    isSet(value) &amp;&amp; !isOrdered(value) ? value :
    emptySet().withMutations(function(set ) {
      var iter = SetIterable(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v ) {return set.add(v)});
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.delete" id="apidoc.element.immutable.Set.prototype.delete">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>delete
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delete = function (value) {
  return updateSet(this, this._map.remove(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.has" id="apidoc.element.immutable.Set.prototype.has">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>has
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (value) {
  return this._map.has(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.intersect" id="apidoc.element.immutable.Set.prototype.intersect">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>intersect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersect = function () {var iters = SLICE$0.call(arguments, 0);
  if (iters.length === 0) {
    return this;
  }
  iters = iters.map(function(iter ) {return SetIterable(iter)});
  var originalSet = this;
  return this.withMutations(function(set ) {
    originalSet.forEach(function(value ) {
      if (!iters.every(function(iter ) {return iter.includes(value)})) {
        set.remove(value);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.merge" id="apidoc.element.immutable.Set.prototype.merge">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function () {
  return this.union.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accepts plain JavaScript Arrays and Objects anywhere a method expects an
`Iterable` with no performance penalty.

```javascript
var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
var map2 = Immutable.Map({c:10, a:20, t:30});
var obj = {d:100, o:200, g:300};
var map3 = map1.<span class="apidocCodeKeywordSpan">merge</span>(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
```

This is possible because `immutable` can treat any JavaScript Array or Object
as an Iterable. You can take advantage of this in order to get sophisticated
collection methods on JavaScript Objects, which otherwise have a very sparse
native API. Because Seq evaluates lazily and does not cache intermediate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.mergeDeep" id="apidoc.element.immutable.Set.prototype.mergeDeep">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeep = function () {
  return this.union.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A few power-tools allow for reading and operating on nested data. The
most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,
`Map` and `OrderedMap`.

```javascript
var nested2 = nested.<span class="apidocCodeKeywordSpan">mergeDeep</span>({a:{b:{d:6}}});
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
```

```javascript
nested2.getIn(['a', 'b', 'd']); // 6

var nested3 = nested2.updateIn(['a', 'b', 'd'], value =&gt; value + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.mergeDeepWith" id="apidoc.element.immutable.Set.prototype.mergeDeepWith">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeDeepWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeDeepWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return this.union.apply(this, iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.mergeWith" id="apidoc.element.immutable.Set.prototype.mergeWith">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>mergeWith
        <span class="apidocSignatureSpan">(merger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeWith = function (merger) {var iters = SLICE$0.call(arguments, 1);
  return this.union.apply(this, iters);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.remove" id="apidoc.element.immutable.Set.prototype.remove">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>remove
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (value) {
  return updateSet(this, this._map.remove(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.sort" id="apidoc.element.immutable.Set.prototype.sort">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>sort
        <span class="apidocSignatureSpan">(comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (comparator) {
  // Late binding
  return OrderedSet(sortFactory(this, comparator));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.sortBy" id="apidoc.element.immutable.Set.prototype.sortBy">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>sortBy
        <span class="apidocSignatureSpan">(mapper, comparator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortBy = function (mapper, comparator) {
  // Late binding
  return OrderedSet(sortFactory(this, comparator, mapper));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.subtract" id="apidoc.element.immutable.Set.prototype.subtract">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>subtract
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subtract = function () {var iters = SLICE$0.call(arguments, 0);
  if (iters.length === 0) {
    return this;
  }
  iters = iters.map(function(iter ) {return SetIterable(iter)});
  var originalSet = this;
  return this.withMutations(function(set ) {
    originalSet.forEach(function(value ) {
      if (iters.some(function(iter ) {return iter.includes(value)})) {
        set.remove(value);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.toString" id="apidoc.element.immutable.Set.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('Set {', '}');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.union" id="apidoc.element.immutable.Set.prototype.union">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>union
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">union = function () {var iters = SLICE$0.call(arguments, 0);
  iters = iters.filter(function(x ) {return x.size !== 0});
  if (iters.length === 0) {
    return this;
  }
  if (this.size === 0 &amp;&amp; !this.__ownerID &amp;&amp; iters.length === 1) {
    return this.constructor(iters[0]);
  }
  return this.withMutations(function(set ) {
    for (var ii = 0; ii &lt; iters.length; ii++) {
      SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.wasAltered" id="apidoc.element.immutable.Set.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this._map.wasAltered();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Set.prototype.withMutations" id="apidoc.element.immutable.Set.prototype.withMutations">
        function <span class="apidocSignatureSpan">immutable.Set.prototype.</span>withMutations
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMutations = function (fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exactly how  `Immutable` applies complex mutations itself.

As an example, building `list2` results in the creation of 1, not 3, new
immutable Lists.

```javascript
var list1 = Immutable.List.of(1,2,3);
var list2 = list1.<span class="apidocCodeKeywordSpan">withMutations</span>(function (list) {
  list.push(4).push(5).push(6);
});
assert(list1.size === 3);
assert(list2.size === 6);
```

Note: `immutable` also provides `asMutable` and `asImmutable`, but only
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Stack" id="apidoc.module.immutable.Stack">module immutable.Stack</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Stack.Stack" id="apidoc.element.immutable.Stack.Stack">
        function <span class="apidocSignatureSpan">immutable.</span>Stack
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack(value) {
  return value === null || value === undefined ? emptyStack() :
    isStack(value) ? value :
    emptyStack().unshiftAll(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.isStack" id="apidoc.element.immutable.Stack.isStack">
        function <span class="apidocSignatureSpan">immutable.Stack.</span>isStack
        <span class="apidocSignatureSpan">(maybeStack)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStack(maybeStack) {
  return !!(maybeStack &amp;&amp; maybeStack[IS_STACK_SENTINEL]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.of" id="apidoc.element.immutable.Stack.of">
        function <span class="apidocSignatureSpan">immutable.Stack.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
  return this(arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.<span class="apidocCodeKeywordSpan">of</span>(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.immutable.Stack.prototype" id="apidoc.module.immutable.Stack.prototype">module immutable.Stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.__ensureOwner" id="apidoc.element.immutable.Stack.prototype.__ensureOwner">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__ensureOwner
        <span class="apidocSignatureSpan">(ownerID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ensureOwner = function (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  if (!ownerID) {
    this.__ownerID = ownerID;
    this.__altered = false;
    return this;
  }
  return makeStack(this.size, this._head, ownerID, this.__hash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.__iterate" id="apidoc.element.immutable.Stack.prototype.__iterate">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__iterate
        <span class="apidocSignatureSpan">(fn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterate = function (fn, reverse) {
  if (reverse) {
    return this.reverse().__iterate(fn);
  }
  var iterations = 0;
  var node = this._head;
  while (node) {
    if (fn(node.value, iterations++, this) === false) {
      break;
    }
    node = node.next;
  }
  return iterations;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.__iterator" id="apidoc.element.immutable.Stack.prototype.__iterator">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>__iterator
        <span class="apidocSignatureSpan">(type, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__iterator = function (type, reverse) {
  if (reverse) {
    return this.reverse().__iterator(type);
  }
  var iterations = 0;
  var node = this._head;
  return new Iterator(function()  {
    if (node) {
      var value = node.value;
      node = node.next;
      return iteratorValue(type, iterations++, value);
    }
    return iteratorDone();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.asImmutable" id="apidoc.element.immutable.Stack.prototype.asImmutable">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>asImmutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asImmutable = function () {
  return this.__ensureOwner();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.asMutable" id="apidoc.element.immutable.Stack.prototype.asMutable">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>asMutable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asMutable = function () {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.clear" id="apidoc.element.immutable.Stack.prototype.clear">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  if (this.size === 0) {
    return this;
  }
  if (this.__ownerID) {
    this.size = 0;
    this._head = undefined;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return emptyStack();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.constructor" id="apidoc.element.immutable.Stack.prototype.constructor">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>constructor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stack(value) {
  return value === null || value === undefined ? emptyStack() :
    isStack(value) ? value :
    emptyStack().unshiftAll(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.get" id="apidoc.element.immutable.Stack.prototype.get">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>get
        <span class="apidocSignatureSpan">(index, notSetValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (index, notSetValue) {
  var head = this._head;
  index = wrapIndex(this, index);
  while (head &amp;&amp; index--) {
    head = head.next;
  }
  return head ? head.value : notSetValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Then require it into any module.

```javascript
var Immutable = require('immutable');
var map1 = Immutable.Map({a:1, b:2, c:3});
var map2 = map1.set('b', 50);
map1.<span class="apidocCodeKeywordSpan">get</span>('b'); // 2
map2.get('b'); // 50
```

### Browser

To use `immutable` from a browser, download [dist/immutable.min.js](https://github.com/facebook/immutable-js/blob/master/dist/immutable
.min.js)
or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.peek" id="apidoc.element.immutable.Stack.prototype.peek">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this._head &amp;&amp; this._head.value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.pop" id="apidoc.element.immutable.Stack.prototype.pop">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  return this.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.push" id="apidoc.element.immutable.Stack.prototype.push">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>push
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function () {
  if (arguments.length === 0) {
    return this;
  }
  var newSize = this.size + arguments.length;
  var head = this._head;
  for (var ii = arguments.length - 1; ii &gt;= 0; ii--) {
    head = {
      value: arguments[ii],
      next: head
    };
  }
  if (this.__ownerID) {
    this.size = newSize;
    this._head = head;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return makeStack(newSize, head);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The difference for the immutable collections is that methods which would mutate
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.of(1, 2);
var list2 = list1.<span class="apidocCodeKeywordSpan">push</span>(3, 4, 5);
var list3 = list2.unshift(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
assert(list4.get(0) === 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.pushAll" id="apidoc.element.immutable.Stack.prototype.pushAll">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>pushAll
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushAll = function (iter) {
  iter = IndexedIterable(iter);
  if (iter.size === 0) {
    return this;
  }
  assertNotInfinite(iter.size);
  var newSize = this.size;
  var head = this._head;
  iter.reverse().forEach(function(value ) {
    newSize++;
    head = {
      value: value,
      next: head
    };
  });
  if (this.__ownerID) {
    this.size = newSize;
    this._head = head;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return makeStack(newSize, head);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.shift" id="apidoc.element.immutable.Stack.prototype.shift">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
  return this.pop.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.slice" id="apidoc.element.immutable.Stack.prototype.slice">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  if (wholeSlice(begin, end, this.size)) {
    return this;
  }
  var resolvedBegin = resolveBegin(begin, this.size);
  var resolvedEnd = resolveEnd(end, this.size);
  if (resolvedEnd !== this.size) {
    // super.slice(begin, end);
    return IndexedCollection.prototype.slice.call(this, begin, end);
  }
  var newSize = this.size - resolvedBegin;
  var head = this._head;
  while (resolvedBegin--) {
    head = head.next;
  }
  if (this.__ownerID) {
    this.size = newSize;
    this._head = head;
    this.__hash = undefined;
    this.__altered = true;
    return this;
  }
  return makeStack(newSize, head);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.toString" id="apidoc.element.immutable.Stack.prototype.toString">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.__toString('Stack [', ']');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.unshift" id="apidoc.element.immutable.Stack.prototype.unshift">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>unshift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function () {
  return this.push.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the collection, like `push`, `set`, `unshift` or `splice` instead return a new
immutable collection. Methods which return new arrays like `slice` or `concat`
instead return new immutable collections.

```javascript
var list1 = Immutable.List.of(1, 2);
var list2 = list1.push(3, 4, 5);
var list3 = list2.<span class="apidocCodeKeywordSpan">unshift</span>(0);
var list4 = list1.concat(list2, list3);
assert(list1.size === 2);
assert(list2.size === 5);
assert(list3.size === 6);
assert(list4.size === 13);
assert(list4.get(0) === 1);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.unshiftAll" id="apidoc.element.immutable.Stack.prototype.unshiftAll">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>unshiftAll
        <span class="apidocSignatureSpan">(iter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshiftAll = function (iter) {
  return this.pushAll(iter);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.wasAltered" id="apidoc.element.immutable.Stack.prototype.wasAltered">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>wasAltered
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasAltered = function () {
  return this.__altered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.immutable.Stack.prototype.withMutations" id="apidoc.element.immutable.Stack.prototype.withMutations">
        function <span class="apidocSignatureSpan">immutable.Stack.prototype.</span>withMutations
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withMutations = function (fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exactly how  `Immutable` applies complex mutations itself.

As an example, building `list2` results in the creation of 1, not 3, new
immutable Lists.

```javascript
var list1 = Immutable.List.of(1,2,3);
var list2 = list1.<span class="apidocCodeKeywordSpan">withMutations</span>(function (list) {
  list.push(4).push(5).push(6);
});
assert(list1.size === 3);
assert(list2.size === 6);
```

Note: `immutable` also provides `asMutable` and `asImmutable`, but only
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>